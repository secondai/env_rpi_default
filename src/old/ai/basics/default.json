[{"_id":"5a2507a2814a49f7ca157cfd","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1512376226820,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507a4814a49f7ca157d0d","nodeId":"5a2507a2814a49f7ca157cfd","type":"code:0.0.1:local:32498h32f2","data":{"key":"b043bd65-9e3d-4bcb-bb89-0327b2e99687","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: generic_cloud_second \n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      // console.log('INPUT:', JSON.stringify(INPUT,null,2));\n      \n      \n      switch(INPUT.type){\n          \n        case 'incoming_first:0.1.1:local:78882h37':\n          \n          console.log('INCOMING FIRST!!');\n          \n          // INPUT is an ExternalIdentityNode\n          // return resolve({\n          //   learning: true,\n          //   INPUT\n          // });\n          \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          console.log('newIdentityNode', JSON.stringify(newIdentityNode,null,2));\n          \n          \n          // STOPPING HERE! \n          // - not \"learning\" anything from remote, just using whatever is currently available (JSON-start)\n          \n          console.log('Created Identity on _first, Second all ready!');\n          \n          // Register Identity on remote \n          let registeredExternal = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'registerOnChain',\n              options: {\n                words: universe.env.STARTUP_REACHABLE_WORDS,\n                publicKey: newIdentityNode.data.public,\n                connection: newIdentityNode.nodes[0].data.connection\n              }\n            }\n          });\n          \n          \n          return resolve({\n            type: 'something2...',\n            data: {\n              createdIdentity: true,\n              registeredExternal\n              // WORDS: universe.env.STARTUP_REACHABLE_WORDS,\n              // publicKey: newIdentityNode.data.public,\n              // connection: newIdentityNode.nodes[0].data.connection\n            }\n          });\n          \n          \n          \n          \n          // Find remote Second \n          // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // - want a publicKey and a URL returned \n          //   - a whole IdentityNode should be returned? \n          // - return: \n          //   - external_identity:0.0.1:local:8982f982j92\n          //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          let remoteValue;\n          try {\n            remoteValue = 'test test'; //WINDOW.prompt('Remote Second','test test');\n          }catch(err){\n            console.error('Not in Tab');\n            remoteValue = 'test test';\n          }\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words: remoteValue\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          // fetch that wallet address, get the first transaction \n          // - first transaction contains IPFS link \n          // - IPFS contains Nodes (without _ids!) \n          let ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          // console.log('Got ExternalIdentityNode',ExternalIdentityNode);\n          \n          // return resolve({\n          //   ExternalIdentityNode,\n          //   error: true,\n          //   remoteValue,\n          //   address\n          // })\n          \n          // return resolve({\n          //   aboutToIdentity: true\n          // });\n          \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n          let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'start',\n              options: {\n                externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n              }\n            }\n          });\n          \n          console.log('FINISHED INITIATE!', authExternalIdentityNode);\n          \n          // console.log('ExternalIdentityNode', JSON.stringify(ExternalIdentityNode,null,2));\n          \n          // Connect to passed-in data (ExternalIdentityNode) \n          // - run a search_internal_datasource action sequence to acquire the code to run \n          // - run the code on local Second  \n          let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                            \n                      {\n                        matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                        dataForAction: {\n                          type: 'string:...',\n                          data: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token is here! pre-downloaded!\n                        }\n                      },\n                      \n                      {\n                        matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        dataForAction: {\n                          type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                          data: {\n                            matchFunctionNode: {\n                              // query here!\n                              // action_pointer:0.0.1:local:238972ncr\n                              type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                              data: {\n                                code: `(()=>{\n                                  // Action \n                                  // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                  \n                                  let inputNode = INPUT.data.inputNode;\n                                  \n                                  if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                    return null;\n                                  }\n                                  \n                                  if(inputNode.data.learn != 'generic_cloud_second'){\n                                    return null;\n                                  }\n                                  \n                                  if(inputNode.nodeId){\n                                    // should be root-level!\n                                    return null;\n                                  }\n                                  \n                                  // strip childnodes\n                                  // delete inputNode.nodes; \n                                  // delete inputNode.parent;\n                                  delete inputNode.data;\n          \n                                  return inputNode;\n                                  \n                                })()`\n                              }\n                            },\n                            // expected/allowed schemas for return \n                            // outputSchemas: [\n                            //   'query_result:0.0.1:local:32490usfj23o23f',\n                            //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                            // ]\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          // console.log('Got Response from TalkToSecond3'); //, JSON.stringify(response,null,2));\n          \n          // Response should include code! \n          let codeResultNode = universe.lodash.find(response.data.actionResponses[1].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          \n          \n          console.log('Got Code to Run for generic_cloud_second');\n          \n          // return resolve({\n          //   runningRemoteCode: true,\n          //   codeResultNode_type: codeResultNode.type\n          // });\n          \n          // Run code in local VM \n          // - INPUT.data is ExternalIdentityNode \n          // - clears local memory, gets remote app, KEEPS local identity! \n          let localResult = await universe.runNodeCodeInVM({\n            codeNode: codeResultNode,\n            dataNode: INPUT.data\n          });\n          \n          return resolve({\n            externalResponse: true,\n            response,\n            codeResultNode,\n            localResult\n          })\n          \n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          \n          // console.log('incoming_web_request!!');\n          // return resolve({\n          //   ok: true\n          // });\n              \n          // if(INPUT.type == 'run_action:0.0.1:local:2398y294c23'){\n            // this is the main/expected input\n            let nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null // root-level\n                  // type: INPUT.type,\n                },\n                // function for returning data from the Node, after filtering a bit \n                // - includes both the Node, and Nodes with nodeId (pointers) \n                filterNodes: tmpNodes=>{\n                  // this runs isolated, outside of the above context? (not sure) \n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.filter(tmpNode=>{\n                      // see if has a ChildNode matching a type \n                      let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                        return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                      })\n                      // 'run_action:0.0.1:local:2398y294c23'\n                      if(!foundMatcherChild){\n                        return false;\n                      }\n                      \n                      // should have no Parent!\n                      // - todo: put into a specific \"directory\" or nodelist\n                      if(tmpNode.parent){\n                        return false;\n                      }\n                      \n                      return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                    });\n                    resolve(tmpNodes);\n                  });\n                },\n              }\n            });\n            \n            // return resolve({\n            //   nodes: nodes.length\n            // });\n            \n            \n            if(nodes.length === 1){\n              // found Node to run for action! \n    \n              let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n              \n              // run in vm, and pass in the inputSchema Node! \n              // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n              let actionResult;\n              try {\n                actionResult = await universe.runNodeCodeInVM({\n                  codeNode, // includes type/schemaName and data \n                  dataNode: INPUT.data, // should be another Node that can be used by the action! \n                  timeout: 15 * 1000\n                });\n              }catch(err){\n                return resolve('FAILED code from incoming_web_request');\n              }\n              \n              // validate actionResult!\n              // - todo\n              \n              return resolve(actionResult);\n              // { \n              //   txt: 'Response:', \n              //   nodeTypes: nodes.map(n=>n.type),\n              //   actionResult\n              // }); // + result);\n              \n            } else {\n              // no Node found for handling action :( \n                \n              return resolve({ \n                error: 'No Nodes for action (incoming_web_request)',\n                INPUT\n              }); // + result);\n            }\n            \n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          break;\n          \n          \n        default:\n          return resolve({\n            type: 'err:..',\n            data: {\n              msg: 'Missing valid input type',\n              INPUT\n            }\n          });\n      }\n\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376228156,"updatedAt":1513150319673,"parent":{"_id":"5a2507a2814a49f7ca157cfd","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1512376226820,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507a5814a49f7ca157d1e","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Storing 'generic_cloud_second' here"},"active":true,"createdAt":1512376229387,"updatedAt":1512441970569,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[]},{"_id":"5a2507b1814a49f7ca157db8","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376241940,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507b3814a49f7ca157dc8","nodeId":"5a2507b1814a49f7ca157db8","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action_sequence: This is for handling a sequence of actions!"},"active":true,"createdAt":1512376243191,"updatedAt":null,"parent":{"_id":"5a2507b1814a49f7ca157db8","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376241940,"updatedAt":null},"nodes":[]},{"_id":"5a2507b4814a49f7ca157dd9","nodeId":"5a2507b1814a49f7ca157db8","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action_sequence:0.0.1:local:293fh8239hsdf23f"},"active":true,"createdAt":1512376244271,"updatedAt":null,"parent":{"_id":"5a2507b1814a49f7ca157db8","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376241940,"updatedAt":null},"nodes":[]},{"_id":"5a2507b5814a49f7ca157dea","nodeId":"5a2507b1814a49f7ca157db8","type":"code:0.0.1:local:32498h32f2","data":{"key":"2f6997c5-7c0f-4864-95e2-00b92047a427","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // return resolve({\n      //   multiple: 'todo: run multiple actions in sequence!'\n      // });\n      \n      // Should be piping information?? \n      // - just looping for now, expecting to store info in the cache, I guess?? \n      let actionResponses = [];\n      let continueActions = true;\n      for(let INPUT_data_idx in INPUT.data.actions){\n        if(!continueActions){\n          continue;\n        }\n        let INPUT_data = INPUT.data.actions[INPUT_data_idx];\n        \n        let x = 1; // this IS available in the filterNode function below!? \n        \n        let nodes = await universe.searchMemory({\n          filter: {\n            // sqlFilter: {\n            //   type: INPUT.type,\n            // },\n            // function for returning data from the Node, after filtering a bit \n            // - includes both the Node, and Nodes with nodeId (pointers) \n            filterNodes: tmpNodes=>{\n              // this runs isolated, outside of the above context? (not sure) \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  // see if has a ChildNode matching a type \n                  \n                  // // must match action type \n                  // if(tmpNode.type != INPUT.data.matchActionType){\n                  //   return false;\n                  // }\n                  // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  if(tmpNode.type != INPUT_data.matchActionType){\n                    return false;\n                  }\n                  // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                  \n                  // // must have code to run! \n                  // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                  //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                  // });\n                  \n                  // if(!foundChildCode){\n                  //   return false;\n                  // }\n                  \n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        \n        // return resolve({\n        //   test: 'ok',\n        //   typeMatch: INPUT.data.matchActionType,\n        //   nodes,\n        //   INPUT,\n        //   SELF\n        // });\n        \n        if(nodes && nodes.length){\n          // found Node to run for action! \n          // - assuming only 1 piece of Code possible/available \n          \n          let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n          \n          // run in vm, and pass in the inputSchema Node! \n          // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n          let actionResult;\n          try {\n            actionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode: INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              timeout: 25 * 1000\n            });\n          }catch(err){\n            // return resolve('FAILED action');\n            actionResponses.push({\n              error: true,\n              msg: 'Failed action',\n              err: (err || '').toString()\n            });\n            continueActions = false;\n            continue;\n          }\n          \n          // validate actionResult!\n          // - todo\n          \n          // adding actionResult to results output\n          // return resolve(actionResult);\n          actionResponses.push(actionResult);\n          \n        } else {\n          // no Node found for handling action :( \n            \n          // return resolve({ \n          //   error: 'No Nodes for action2'\n          // }); // + result);\n          actionResponses.push({ \n            action3: INPUT_data,\n            error: 'No Nodes for action2'\n          });\n        }\n        \n      }\n      \n      // resolve all\n      resolve({\n        actionResponses\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512376245749,"updatedAt":1513150320158,"parent":{"_id":"5a2507b1814a49f7ca157db8","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376241940,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507b7814a49f7ca157dfb","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376247495,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507b8814a49f7ca157e0c","nodeId":"5a2507b7814a49f7ca157dfb","type":"text_tag:0.0.1:local:239fj23","data":{"text":"generic_cloud_second_startup"},"active":true,"createdAt":1512376248735,"updatedAt":1512461954105,"parent":{"_id":"5a2507b7814a49f7ca157dfb","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376247495,"updatedAt":null},"nodes":[]},{"_id":"5a2507ba814a49f7ca157e1e","nodeId":"5a2507b7814a49f7ca157dfb","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"cloud_startup:0.0.1:local:98h198hf32"},"active":true,"createdAt":1512376250056,"updatedAt":1512462057855,"parent":{"_id":"5a2507b7814a49f7ca157dfb","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376247495,"updatedAt":null},"nodes":[]},{"_id":"5a2507bb814a49f7ca157e2e","nodeId":"5a2507b7814a49f7ca157dfb","type":"code:0.0.1:local:32498h32f2","data":{"key":"e32dd823-be68-4360-917a-48c0c8314bc5","code":"(()=>{\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // Handles \"startup\" on a cloud server \n      console.log('Startup on Cloud OK!');\n      \n      return resolve({\n        type: 'boolean:...',\n        data: true\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512376251432,"updatedAt":1513150320554,"parent":{"_id":"5a2507b7814a49f7ca157dfb","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376247495,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507bc814a49f7ca157e3f","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376252648,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507bd814a49f7ca157e50","nodeId":"5a2507bc814a49f7ca157e3f","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ping:pong"},"active":true,"createdAt":1512376253901,"updatedAt":null,"parent":{"_id":"5a2507bc814a49f7ca157e3f","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376252648,"updatedAt":null},"nodes":[]},{"_id":"5a2507bf814a49f7ca157e61","nodeId":"5a2507bc814a49f7ca157e3f","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"ping:0.0.1:local:239fh298fh239h23"},"active":true,"createdAt":1512376255529,"updatedAt":null,"parent":{"_id":"5a2507bc814a49f7ca157e3f","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376252648,"updatedAt":null},"nodes":[]},{"_id":"5a2507c0814a49f7ca157e72","nodeId":"5a2507bc814a49f7ca157e3f","type":"code:0.0.1:local:32498h32f2","data":{"key":"525d1100-71ab-40fc-893e-02940e7b7211","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      resolve({\n        type: 'pong:0.0.1:local:8992389hfdg',\n        data: 'pong'\n      })\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512376256893,"updatedAt":1513150321390,"parent":{"_id":"5a2507bc814a49f7ca157e3f","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512376252648,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507ce814a49f7ca157f0b","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512376270131,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507cf814a49f7ca157f1c","nodeId":"5a2507ce814a49f7ca157f0b","type":"code:0.0.1:local:32498h32f2","data":{"key":"619427af-8b4b-4c58-975f-9cc95f55d6f6","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'new':\n          console.log('Getting new rsa instance');\n          return resolve({\n            type: 's....',\n            data: new universe.rsa(inputOpts)\n          })\n          \n        \n        case 'sign':\n        \n          let stringToSign = inputOpts.stringToSign;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getPrivate',\n              options: {}\n            }\n          });\n          \n          console.log('MY privateIdentity NODE', MyPrivateIdentity);\n          \n          // // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          // let myPublicKey = MyPrivateIdentity.data.public;\n          \n          // let IdentityNode = await getPrivateIdentity();\n          let privateKey = MyPrivateIdentity.data.private;\n\n          let key1 = new universe.rsa(privateKey);\n          let signed = key1.sign(stringToSign);\n\n          return resolve({\n            type: 'string:0.0.1:local:289hf329h93',\n            data: signed.toString('base64')\n          });\n\n          \n        \n        case 'verify':\n          console.log('Verifying', inputOpts);\n          let ChallengeVerifyNode = inputOpts.ChallengeVerifyNode;\n          let key2 = new universe.rsa(ChallengeVerifyNode.data.publicKey);\n\n          let verified = key2.verify(ChallengeVerifyNode.data.challenge, ChallengeVerifyNode.data.solution, undefined, 'base64'); // todo\n\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: verified\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376271724,"updatedAt":1513150321754,"parent":{"_id":"5a2507ce814a49f7ca157f0b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512376270131,"updatedAt":null},"nodes":[]},{"_id":"5a2507d1814a49f7ca157f2d","nodeId":"5a2507ce814a49f7ca157f0b","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: rsa"},"active":true,"createdAt":1512376273252,"updatedAt":1512442628593,"parent":{"_id":"5a2507ce814a49f7ca157f0b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512376270131,"updatedAt":null},"nodes":[]},{"_id":"5a2507d2814a49f7ca157f3e","nodeId":"5a2507ce814a49f7ca157f0b","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512376274773,"updatedAt":null,"parent":{"_id":"5a2507ce814a49f7ca157f0b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"rsa","version":"1.0.0"},"active":true,"createdAt":1512376270131,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507d4814a49f7ca157f50","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512376276508,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507d6814a49f7ca157f61","nodeId":"5a2507d4814a49f7ca157f50","type":"code:0.0.1:local:32498h32f2","data":{"key":"e7af1532-eb2b-45f6-8673-79199855e487","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let nodeResponse = await universe.loadAndRunCapability('Request',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'make',\n              options: {\n                ExternalIdentityNode,\n                RequestNode\n              }\n            }\n          });\n          \n          return resolve(nodeResponse);\n            \n          // let nodeResponse = await universe. TalkToSecond({\n          //   ExternalIdentityNode: INPUT,\n          //   InputNode: {\n          //     type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //     data: {\n          //       actions: [\n          //         {\n          //           matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //           dataForAction: {\n          //             type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //             data: {\n          //               matchFunctionNode: {\n          //                 // query here!\n          //                 // action_pointer:0.0.1:local:238972ncr\n          //                 type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                 data: {\n          //                   code: codeSearchTemplate\n          //                 }\n          //               },\n          //               // expected/allowed schemas for return \n          //               // outputSchemas: [\n          //               //   'query_result:0.0.1:local:32490usfj23o23f',\n          //               //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //               // ]\n          //             }\n          //           }\n          //         }\n          //       ]\n                \n          //     }\n          //   }\n          // });\n          \n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376278337,"updatedAt":1513150322073,"parent":{"_id":"5a2507d4814a49f7ca157f50","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512376276508,"updatedAt":null},"nodes":[]},{"_id":"5a2507d7814a49f7ca157f71","nodeId":"5a2507d4814a49f7ca157f50","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: TalkToSecond"},"active":true,"createdAt":1512376279866,"updatedAt":1512442636735,"parent":{"_id":"5a2507d4814a49f7ca157f50","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512376276508,"updatedAt":null},"nodes":[]},{"_id":"5a2507d9814a49f7ca157f82","nodeId":"5a2507d4814a49f7ca157f50","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512376281285,"updatedAt":null,"parent":{"_id":"5a2507d4814a49f7ca157f50","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"TalkToSecond","version":"1.0.0"},"active":true,"createdAt":1512376276508,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507da814a49f7ca157f94","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512376282961,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507dc814a49f7ca157fa5","nodeId":"5a2507da814a49f7ca157f94","type":"code:0.0.1:local:32498h32f2","data":{"key":"8900db23-3166-4efc-a099-e39cc790bc84","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, authToken } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      // return resolve({\n      //   INPUT\n      // });\n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      \n      // Need to create a local Identity, and authenticate with the remote Second to Learn from \n      // - uses a constant value (token) from the remote Second! \n      let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'getPrivate',\n          options: {}\n        }\n      });\n      \n      console.log('MY privateIdentity NODE', MyPrivateIdentity);\n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      // ExternalIdentityNode\n      console.log('Making ExternalInitialResponseNodeFull request');\n      let ExternalInitialResponseNodeFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedInitiateIdentifyNode\n          }\n        }\n      });\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      console.log('ExternalInitialResponseNodeFull',ExternalInitialResponseNodeFull);\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      console.log('Verifying challenge I sent', ExternalInitialResponseNode, ExternalIdentityNode);\n      let verified = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'verify',\n          options: {\n            ChallengeVerifyNode:{\n              type: '...',\n              data: {\n                challenge: newChallenge,\n                solution: ExternalInitialResponseNode.data.solution,\n                publicKey: ExternalIdentityNode.data.publicKey\n              }\n            }\n          }\n        }\n      });\n      \n      console.log('Local Verified response:', verified);\n      \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      \n      console.log('Signing remote challenge', ExternalInitialResponseNode);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign: ExternalInitialResponseNode.data.challenge\n          }\n        }\n      });\n      \n      console.log('Local SignedNode response:', SignedNode);\n      \n      \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      let privateConnectMethod = universe.lodash.find(MyPrivateIdentity.nodes, { type: 'private_identity_connect_method:0.0.1:local:9081j29h3' });\n      \n      console.log('AFter Search');\n      \n      if(privateConnectMethod){\n        console.log('Has privateConnectMethod!!!!', privateConnectMethod);\n      } else {\n        console.log('NO privateConnectMethod???');\n      }\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting an encrypted token back for later auth requests \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data, // base64 string \n          connectMethod: privateConnectMethod ? privateConnectMethod.data : undefined\n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      \n      console.log('Making ExternalTokenResponseFull request with WrappedTokenNode', WrappedTokenNode);\n      let ExternalTokenResponseFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedTokenNode\n          }\n        }\n      });\n      \n      console.log('Local ExternalTokenResponseFull response:', ExternalTokenResponseFull);\n      \n      \n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      console.log('AT IDENTIFY STAGE 2', ExternalIdentityNode);\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      \n      console.log('Updating ExternalIdentityNode', ExternalIdentityNode);\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      console.log('Updated!');\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376284493,"updatedAt":1513150322501,"parent":{"_id":"5a2507da814a49f7ca157f94","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512376282961,"updatedAt":null},"nodes":[]},{"_id":"5a2507de814a49f7ca157fb6","nodeId":"5a2507da814a49f7ca157f94","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyInitiate"},"active":true,"createdAt":1512376286119,"updatedAt":1512442646561,"parent":{"_id":"5a2507da814a49f7ca157f94","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512376282961,"updatedAt":null},"nodes":[]},{"_id":"5a2507df814a49f7ca157fc6","nodeId":"5a2507da814a49f7ca157f94","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512376287769,"updatedAt":null,"parent":{"_id":"5a2507da814a49f7ca157f94","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"IdentifyInitiate","version":"1.0.0"},"active":true,"createdAt":1512376282961,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507e1814a49f7ca157fd7","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512376289734,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507e3814a49f7ca157fe8","nodeId":"5a2507e1814a49f7ca157fd7","type":"code:0.0.1:local:32498h32f2","data":{"key":"e830f0fd-5313-48a7-8518-c431c5b4c7bb","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'createLocal': // should only happen once! \n          console.log('Create a new Local Private Identity');\n              \n          var key = new universe.rsa({b: 512});\n          key.generateKeyPair(512, 65537); // 2048\n          \n          const keypair = {\n            private: key.exportKey('pkcs8-private-pem'), \n            public: key.exportKey('pkcs8-public-pem'),\n          }\n          \n          let NodeToSave = {\n            type: 'identity_private:0.0.1:local:3298f2j398233',\n            data: keypair\n          }\n          \n          // save Node to memory\n          let savedNode = await universe.newNode(NodeToSave);\n          \n          // save the connectMethod as well \n          let connectionUrl = 'http://localhost:9999';\n          if(universe.env.HEROKU_APP_NAME){\n            connectionUrl = `http://${universe.env.HEROKU_APP_NAME}.herokuapp.com/ai`; \n          }\n          if(universe.env.PUBLIC_HOST == 'ngrok.io'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          if(universe.env.PUBLIC_HOST == 'herokuapp.com'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          console.log('CONNECTION_URL:', connectionUrl);\n          \n          let childNodeToSave = {\n            nodeId: savedNode._id,\n            type: 'private_identity_connect_method:0.0.1:local:9081j29h3',\n            data: {\n              method: 'http',\n              connection: connectionUrl\n            }\n          }\n          \n          let savedChildNode = await universe.newNode(childNodeToSave);\n          // delete savedChildNode.parent; // kill recursion\n          savedNode.nodes = [savedChildNode];\n          \n          return resolve(savedNode);\n          \n        case 'getPrivate':\n        \n          let privateNodes;\n          try{\n            privateNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'identity_private:0.0.1:local:3298f2j398233'\n                }\n              }\n            });\n            if(!privateNodes.length){\n              throw \"No private identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no identity'\n            });\n          }\n\n          let IdentityNode = privateNodes[0];\n          return resolve(IdentityNode);\n          \n        case 'getExternal':\n        \n          let externalNodes;\n          try{\n            externalNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: inputOpts.publicKey\n                  }\n                }\n              }\n            });\n            if(!externalNodes.length){\n              throw \"No external identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no external identity match'\n            });\n          }\n\n          let ExternalIdentityNode = externalNodes[0];\n          return resolve(ExternalIdentityNode);\n          \n          \n        case 'registerOnChain':\n          let remoteCreated = await universe.createAddressForIdentity(inputOpts.words, inputOpts.publicKey, inputOpts.connection)\n          return resolve(remoteCreated);\n          \n          \n        case 'saveExternal':\n          // Duplicate publicKeys get updated! \n          \n          console.log('saveExternal inputOpts', inputOpts);\n          \n          let externalNodes3 = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n                }\n              }\n            }\n          });\n          \n          let NodeToSave3 = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n            }\n          }\n          \n          if(externalNodes3 && externalNodes3.length){\n            // exists!\n            NodeToSave3._id = externalNodes3[0]._id;\n          }\n          \n          // external_identity:0.0.1:local:8982f982j92\n          // external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // save Node to memory\n          let savedNode3;\n          if(NodeToSave3._id){\n            savedNode3 = await universe.updateNode(NodeToSave3);\n          } else {\n            savedNode3 = await universe.newNode(NodeToSave3);\n          }\n          \n          // save/update the connectMethod as well \n          if(inputOpts.ExternalIdentityNode.nodes){\n            let childNodeToSave3 = {\n              nodeId: savedNode3._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: inputOpts.ExternalIdentityNode.nodes[0].data\n            }\n            \n            let savedChildNode3;\n            if(externalNodes3 && externalNodes3.length && externalNodes3[0].nodes){\n              childNodeToSave3._id = externalNodes3[0].nodes[0]._id;\n              savedChildNode3 = await universe.updateNode(childNodeToSave3);\n            } else {\n              savedChildNode3 = await universe.newNode(childNodeToSave3);\n            }\n          }\n          \n          console.log('Saved External, locally');\n          \n          let NewExternalNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getExternal',\n              options: {\n                publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n              }\n            }\n          });\n          \n          console.log('Got New/UpdatedExternalNode', NewExternalNode);\n          \n          return resolve(NewExternalNode);\n          \n          \n        \n        case 'getAddressForWords':\n          // inputOpts.words = String;\n          // transform to \"string[space]string[space]string[space]\" format \n          let remoteValue = universe.lodash.compact(inputOpts.words.split(' ')).join(' ');\n          // transform to wallet address \n          var hash = universe.bitcoin.crypto.sha256(remoteValue)\n          console.log('hash:', hash);\n          var d = universe.bigi.fromBuffer(hash)\n          console.log('d:', d);\n          var keyPair = new universe.bitcoin.ECPair(d)\n          var address = keyPair.getAddress()\n          console.log('Remote Second Wallet Address', address);\n          return resolve({\n            type:'wallet_address:..',\n            data: address\n          })\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376291062,"updatedAt":1513150322846,"parent":{"_id":"5a2507e1814a49f7ca157fd7","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512376289734,"updatedAt":null},"nodes":[]},{"_id":"5a2507e4814a49f7ca157ffa","nodeId":"5a2507e1814a49f7ca157fd7","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Identity"},"active":true,"createdAt":1512376292529,"updatedAt":1512442655934,"parent":{"_id":"5a2507e1814a49f7ca157fd7","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512376289734,"updatedAt":null},"nodes":[]},{"_id":"5a2507e5814a49f7ca15800b","nodeId":"5a2507e1814a49f7ca157fd7","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512376293948,"updatedAt":null,"parent":{"_id":"5a2507e1814a49f7ca157fd7","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Identity","version":"1.0.0"},"active":true,"createdAt":1512376289734,"updatedAt":null},"nodes":[]}]},{"_id":"5a2507e7814a49f7ca15801b","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512376295660,"updatedAt":null,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2507e9814a49f7ca15802c","nodeId":"5a2507e7814a49f7ca15801b","type":"code:0.0.1:local:32498h32f2","data":{"key":"90bd3427-5301-415d-ac12-c3f9a3c530d0","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'make':\n        \n          console.log('Make Request inputOpts', inputOpts);\n          \n          // Make a request to an external Second \n          // inputOpts: {\n          //   ExternalIdentityNode, // must include connect_method\n          //   RequestNode: InitiateIdentifyNode\n          // }\n          \n          // let ExternalRequestNode = inputOpts.ExternalIdentityNode;\n\n          // ExternalIdentityNode needs to have a NodeChild w/ a connect_method \n          let connectNode = universe.lodash.find(inputOpts.ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n          if(!connectNode){\n            console.error('Missing ConnectNode!');\n            return reject({\n              type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n              data: {\n                str: 'Missing existing ExternalIdentity connect_method child!'\n              }\n            })\n          }\n\n          console.log('Making external request');\n\n          // make web request\n          // - just passing through, assume any Auth is already included? \n          let response = await universe.directToSecond({\n            url: connectNode.data.connection,\n            RequestNode: inputOpts.RequestNode,\n            // method: 'post',\n            // url: connectNode.data.connection, // expecting URL at first! \n            // body: ExternalRequestNode.data.RequestNode,\n            // json: true\n          })\n\n          // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          return resolve(response.secondResponse);\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512376297612,"updatedAt":1513150323169,"parent":{"_id":"5a2507e7814a49f7ca15801b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512376295660,"updatedAt":null},"nodes":[]},{"_id":"5a2507eb814a49f7ca15803d","nodeId":"5a2507e7814a49f7ca15801b","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Request"},"active":true,"createdAt":1512376299163,"updatedAt":1512442662604,"parent":{"_id":"5a2507e7814a49f7ca15801b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512376295660,"updatedAt":null},"nodes":[]},{"_id":"5a2507ed814a49f7ca15804e","nodeId":"5a2507e7814a49f7ca15801b","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1512376301178,"updatedAt":null,"parent":{"_id":"5a2507e7814a49f7ca15801b","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"Request","version":"1.0.0"},"active":true,"createdAt":1512376295660,"updatedAt":null},"nodes":[]}]},{"_id":"5a273ef19bd7021a55d5b371","type":"internal_user:0.0.1:local:98h32","data":{"roles":["root"],"passphrase":"testuserpassphrase"},"active":true,"createdAt":1512521457317,"updatedAt":1512522241228,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[]},{"_id":"5a2765859bd7021a55d5bc0b","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2765869bd7021a55d5bc1b","nodeId":"5a2765859bd7021a55d5bc0b","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512531334528,"updatedAt":null,"parent":{"_id":"5a2765859bd7021a55d5bc0b","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159},"nodes":[]},{"_id":"5a2765899bd7021a55d5bc2c","nodeId":"5a2765859bd7021a55d5bc0b","type":"code:0.0.1:local:32498h32f2","data":{"key":"85ad165c-ff0a-43ce-9973-557aaa933357","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Receiving an INPUT.data.passphrase for logging in! \n      // - MUST already be identified (in requests hash) \n      // - upgrades the internal hash to include a user?\n      \n      // get whatever is currently stored \n      // internalUserPassphrase = passphrase\n\n      // Find the InternalUser with that passphrase \n      // - todo: bcrypt! \n      \n      // if found User, then create a new Token that will be used for Identity \n      \n      // INPUT = {\n      //   type: 'internal_user_passphrase:0.0.1:local:289fh239h38h2',\n      //   data: {\n      //     passphrase: String\n      //   }\n      // }\n      \n      let requestCache = await universe.getRequestCache();\n      \n      let IdentityNode;\n      try {\n        IdentityNode = requestCache.keyvalue.IdentityNode;\n      }catch(err){\n      }\n      \n      if(!IdentityNode){\n        return resolve({\n          type: 'error:...',\n          data: {\n            msg: 'Missing IdentityNode in request (should use a run_action_sequence and include auth!)'\n          }\n        });\n      }\n      \n      \n      \n      \n      // Find the InternalUser for that passphrase \n      let internalUserMatches = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null,\n            type: 'internal_user:0.0.1:local:98h32',\n            data: {\n              passphrase: INPUT.data.passphrase\n            }\n          }\n        }\n      });\n      \n      if(!internalUserMatches || !internalUserMatches.length){\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Missing InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase,\n            INPUT\n          }\n        });\n      }\n      \n      if(internalUserMatches.length > 1){\n        console.error('Matched multiple internalUsers!');\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Multiple InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase\n          }\n        });\n      }\n      \n      let InternalUserNode = internalUserMatches[0];\n      \n      \n      // Upgrade the user's token with the InternalUser Node \n      \n      \n      \n      // Return a new token to use for subsequent requests \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: IdentityNode._id, //ExternalIdentityNode._id,\n          publicKey: IdentityNode.data.publicKey,\n          internalUserId: InternalUserNode._id\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds',\n        data: {\n          verified: true,\n          token,\n          IdentityNode\n        }\n      });\n        \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512531337541,"updatedAt":1513150325289,"parent":{"_id":"5a2765859bd7021a55d5bc0b","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159},"nodes":[]},{"_id":"5a27658a9bd7021a55d5bc3c","nodeId":"5a2765859bd7021a55d5bc0b","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: Upgrade token for identified external (incoming) as an Internal User. Given a passphrase"},"active":true,"createdAt":1512531338837,"updatedAt":null,"parent":{"_id":"5a2765859bd7021a55d5bc0b","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159},"nodes":[]},{"_id":"5a27658c9bd7021a55d5bc4d","nodeId":"5a2765859bd7021a55d5bc0b","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512531340100,"updatedAt":null,"parent":{"_id":"5a2765859bd7021a55d5bc0b","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159},"nodes":[]},{"_id":"5a27658d9bd7021a55d5bc5f","nodeId":"5a2765859bd7021a55d5bc0b","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531341590,"updatedAt":null,"parent":{"_id":"5a2765859bd7021a55d5bc0b","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1512531333260,"updatedAt":1512531352159},"nodes":[]}]},{"_id":"5a2765b29bd7021a55d5bc88","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2765b39bd7021a55d5bc98","nodeId":"5a2765b29bd7021a55d5bc88","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512531379793,"updatedAt":null,"parent":{"_id":"5a2765b29bd7021a55d5bc88","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082},"nodes":[]},{"_id":"5a2765b59bd7021a55d5bca9","nodeId":"5a2765b29bd7021a55d5bc88","type":"code:0.0.1:local:32498h32f2","data":{"key":"cab7f1c9-d371-4b3c-8e34-1289a9821bb1","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // // INPUT:\n      // {\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: 'randomstring/nonce'\n      // }\n      \n      // Challenge start\n      // - get sent something to prove who I am (or who I represent [am signing for])\n      //   - this might be different than what the requestor is expecting! they should handle it accordingly \n      // - return my public key, signed challenge \n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      \n      \n      \n      let newChallenge = universe.uuidv4();\n      \n      \n      // universe.console.log('GOT2 NewChallenge:', INPUT.data.challenge, newChallenge); //, INPUT.data.challenge);\n      \n      \n      // Just using capabilities to sign \n      // - signed result is a StringNode \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: INPUT.data.challenge\n      });\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      //- todo...\n      \n      // Store our challenge (and the publicKey we were sent) in memory, to check in another request/response!\n      universe.globalCache[INPUT.data.publicKey] = newChallenge;\n      \n      \n      resolve({\n        type: 'challenge_start_response:0.0.1:local:2378f37723f22dxc',\n        data: {\n          solution: SignedNode.data,\n          challenge: newChallenge\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512531381718,"updatedAt":1513150325686,"parent":{"_id":"5a2765b29bd7021a55d5bc88","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082},"nodes":[]},{"_id":"5a2765b69bd7021a55d5bcba","nodeId":"5a2765b29bd7021a55d5bc88","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: start challenge"},"active":true,"createdAt":1512531382917,"updatedAt":null,"parent":{"_id":"5a2765b29bd7021a55d5bc88","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082},"nodes":[]},{"_id":"5a2765b89bd7021a55d5bccb","nodeId":"5a2765b29bd7021a55d5bc88","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512531384351,"updatedAt":null,"parent":{"_id":"5a2765b29bd7021a55d5bc88","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082},"nodes":[]},{"_id":"5a2765b99bd7021a55d5bcdc","nodeId":"5a2765b29bd7021a55d5bc88","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531385699,"updatedAt":null,"parent":{"_id":"5a2765b29bd7021a55d5bc88","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1512531378716,"updatedAt":1512531393082},"nodes":[]}]},{"_id":"5a2765d09bd7021a55d5bd05","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2765d19bd7021a55d5bd15","nodeId":"5a2765d09bd7021a55d5bd05","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512531409417,"updatedAt":null,"parent":{"_id":"5a2765d09bd7021a55d5bd05","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833},"nodes":[]},{"_id":"5a2765d29bd7021a55d5bd26","nodeId":"5a2765d09bd7021a55d5bd05","type":"code:0.0.1:local:32498h32f2","data":{"key":"08b17f71-3221-4919-a875-af0b4522f81b","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Challenge solved by caller (or so they say) \n      // - create Node for ExternalIdentity: publicKey, approvedDatetime\n      // - return JWT that client should use for subsequent requests \n      \n      // old: also receiving an INPUT.data.internalUserPassphrase for logging in! \n      \n      let storedChallenge = universe.globalCache[INPUT.data.publicKey];\n      \n      // check stored challenge with passed-in (any reason? seems ok) \n      if(storedChallenge != INPUT.data.challengeReceived){\n        return resolve({\n          type: 'error',\n          data: {\n            str: 'invalid storedChallenge != challengeReceived'\n          }\n        })  \n      }\n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: storedChallenge,\n          solution: INPUT.data.solution,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      if(!verified.data){\n        return resolve({\n          type: 'error...',\n          data: {\n            err: 'Failed verifiation!'\n          }\n        });\n      }\n      \n      // Create local Node for ExternalIdentity \n      // - they should have already passed up a token I can use for auth (if I want to reach this Second again) \n      // - should also have the connect_method setup! \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data.publicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      let ExternalIdentityNode\n      if(nodes.length){\n        // Exists already \n        ExternalIdentityNode = nodes[0];\n        \n        // todo: get updated connectMethod!!!\n        universe.console.error('Expecting connectMethod for one we are creating');\n        universe.console.error('Received:', JSON.stringify(INPUT, null, 2));\n        \n        // update connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          if(ExternalIdentityNode.nodes){\n            // has existing connect_method to be updated\n            \n            console.log('Updating existing connect_method for external child');\n            \n            let updateChild = {\n              _id: ExternalIdentityNode.nodes[0]._id,\n              nodeId: ExternalIdentityNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let updatedChild = await universe.updateNode(updateChild);\n            \n          } else {\n            // no existing connect_method\n            let newChild = {\n              nodeId: savedNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let savedChild = await universe.newNode(newChild);\n          }\n        }\n        \n        \n      } else {\n        // no Node created yet (this is expected for each \"new\" Second) \n        \n        // go ahead and create new ExternalIdentityNode \n        // - also creating the Connect Method to use \n        //   - it would have been sent up (\"reach me X way\") \n        \n        let newNode = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            publicKey: INPUT.data.publicKey\n          }\n        }\n        \n        let savedNode = await universe.newNode(newNode);\n        \n        // create connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          let newChild2 = {\n            nodeId: savedNode._id,\n            type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n            data: INPUT.data.connectMethod\n          }\n          let savedChild2 = await universe.newNode(newChild2);\n        }\n        \n        // get normal Node for rest of call \n        ExternalIdentityNode = await universe.findNode({_id: savedNode._id});\n        \n      }\n      \n      \n      // // get internal_user that we are authorizing as (using \"upgrade\" path now...)\n      // // - should ERROR if fail! \n      // if(INPUT.data.internalUserPassphrase){\n        \n      // }\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      // Created encrypted token for identification \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: ExternalIdentityNode._id,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'challenge_token_response:0.0.1:local:928h92h3223fdfsdf23',\n        data: {\n          verified: true,\n          token\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512531410771,"updatedAt":1513150326009,"parent":{"_id":"5a2765d09bd7021a55d5bd05","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833},"nodes":[]},{"_id":"5a2765d49bd7021a55d5bd36","nodeId":"5a2765d09bd7021a55d5bd05","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: challenge response (solved, proving who I am). Saving External locally. Returning JWT."},"active":true,"createdAt":1512531412974,"updatedAt":null,"parent":{"_id":"5a2765d09bd7021a55d5bd05","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833},"nodes":[]},{"_id":"5a2765d69bd7021a55d5bd47","nodeId":"5a2765d09bd7021a55d5bd05","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512531414466,"updatedAt":null,"parent":{"_id":"5a2765d09bd7021a55d5bd05","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833},"nodes":[]},{"_id":"5a2765d79bd7021a55d5bd59","nodeId":"5a2765d09bd7021a55d5bd05","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531415990,"updatedAt":null,"parent":{"_id":"5a2765d09bd7021a55d5bd05","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1512531408299,"updatedAt":1512531422833},"nodes":[]}]},{"_id":"5a2766029bd7021a55d5bd82","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2766049bd7021a55d5bd93","nodeId":"5a2766029bd7021a55d5bd82","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512531460211,"updatedAt":null,"parent":{"_id":"5a2766029bd7021a55d5bd82","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279},"nodes":[]},{"_id":"5a2766059bd7021a55d5bda3","nodeId":"5a2766029bd7021a55d5bd82","type":"code:0.0.1:local:32498h32f2","data":{"key":"87889324-ce31-45f8-b80d-4f6d7a39f356","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let nodeId;\n      let publicKey;\n      let internalUserId; // for InternalUser \n      let InternalUserNode;\n      let tokenNode;\n      let decrypted;\n      let encrypted;\n      try {\n        \n          \n        // // Created encrypted token for identification \n        // let tokenDataString = JSON.stringify({\n        //   type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        //   data: {\n        //     internalId: null,\n        //     publicKey: 'learn'\n        //   }\n        // });\n        // // encrypt_string:0.0.1:local:329fj2938\n        // encrypted = await universe.capabilities().encryptPrivate({\n        //   type: 'string',\n        //   data: tokenDataString\n        // });\n        \n        decrypted = await universe.capabilities().decryptPrivate({\n          type: 'string',\n          data: INPUT.data\n        });\n        \n        // get the local public key from decrypted package (JSON string) \n        if(decrypted.type != 'string:0.0.1:local:289hf329h93'){\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: false,\n            extra: {\n              msg: 'Failed decrypting INPUT.data',\n              inputData: INPUT.data ? INPUT.data : 'NO INPUT DATA PROVIDED',\n              INPUT,\n              decrypted,\n              // encrypted,\n            }\n          });\n        }\n        tokenNode = JSON.parse(decrypted.data);\n        \n        nodeId = tokenNode.data.internalId;\n        publicKey = tokenNode.data.publicKey;\n        internalUserId = tokenNode.data.internalUserId;\n        // todo: expiresAt (force re-auth)\n      }catch(err){\n        return resolve({\n          type: 'boolean:0.0.1:local:98h8fh28h3232f',\n          data: false,\n          extra: {\n            INPUT,\n            decrypted,\n            // encrypted,\n            verified: false,\n            err: true,\n            errStr: err.toString()\n          }\n        });\n      }\n      \n      // create some default ExternalIdentityNodes for certain private keys \n      // - \"learning\" for example\n      let ExternalIdentityNode;\n      \n      switch(publicKey){\n        case 'learn':\n          // allow anyone who was pre-allowed \n            \n          ExternalIdentityNode = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              roles: ['learn'],\n              publicKey\n            }\n          }\n          \n          break;\n        \n        \n        default:\n          // actual publicKey passed in \n          \n          // Get local ExternalIdentity if it exists \n          // - should exist, unless we deleted it! \n          let nodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                _id: nodeId,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: publicKey\n                }\n              },\n              // function for returning data from the Node, after filtering a bit \n              // - includes both the Node, and Nodes with nodeId (pointers) \n              filterNodes: tmpNodes=>{\n                return tmpNodes;\n              }\n            }\n          });\n          \n          if(!nodes || !nodes.length){\n            \n            return resolve({\n              type: 'boolean:0.0.1:local:98h8fh28h3232f',\n              data: {\n                missingNode: true,\n                INPUT,\n              }\n            });\n            \n          }\n          \n          ExternalIdentityNode = nodes[0];\n          \n          // see if the InternalUser should also be included\n          if(internalUserId){\n            let InternalUserNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  _id: internalUserId,\n                  type: 'internal_user:0.0.1:local:98h32',\n                }\n              }\n            });\n            if(InternalUserNodes.length){\n              InternalUserNode = InternalUserNodes[0];\n            } else {\n              console.error('Missing as InternalUser');\n            }\n          }\n           \n          break;\n        \n      }\n      \n      \n      // set in request cache \n      await universe.setRequestCacheKeyValue('IdentityNode',ExternalIdentityNode);\n      await universe.setRequestCacheKeyValue('InternalUserNode',InternalUserNode);\n      \n      return resolve({\n        type: 'boolean:0.0.1:local:98h8fh28h3232f',\n        data: true,\n        ExternalIdentityNode,\n        decrypted,\n        internalUserId,\n        InternalUserNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512531461417,"updatedAt":1513150327268,"parent":{"_id":"5a2766029bd7021a55d5bd82","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279},"nodes":[]},{"_id":"5a2766069bd7021a55d5bdb4","nodeId":"5a2766029bd7021a55d5bd82","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: adds ExternalIdentity to requestsCache, according to the token that is passed in"},"active":true,"createdAt":1512531462741,"updatedAt":null,"parent":{"_id":"5a2766029bd7021a55d5bd82","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279},"nodes":[]},{"_id":"5a2766099bd7021a55d5bdc4","nodeId":"5a2766029bd7021a55d5bd82","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512531465465,"updatedAt":null,"parent":{"_id":"5a2766029bd7021a55d5bd82","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279},"nodes":[]},{"_id":"5a27660a9bd7021a55d5bdd5","nodeId":"5a2766029bd7021a55d5bd82","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531466774,"updatedAt":null,"parent":{"_id":"5a2766029bd7021a55d5bd82","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1512531458629,"updatedAt":1512531470279},"nodes":[]}]},{"_id":"5a27666c9bd7021a55d5bdff","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a27666d9bd7021a55d5be10","nodeId":"5a27666c9bd7021a55d5bdff","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512531565372,"updatedAt":null,"parent":{"_id":"5a27666c9bd7021a55d5bdff","nodeId":"5a2507a1814a49f7ca157ced","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629},"nodes":[]},{"_id":"5a2766709bd7021a55d5be20","nodeId":"5a27666c9bd7021a55d5bdff","type":"code:0.0.1:local:32498h32f2","data":{"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return resolve({\n      //   SEARCHING: 'seraching internal datasource!',\n      //   INPUT,\n      //   SELF\n      // });\n      \n      // schema/format of INPUT data: standard_query_request:0.0.1:local:65723f2khfds\n      \n      await universe.historyLog({INPUT}, 'searching-internal-datasource', 'debug')\n      \n      \n      // When searching: (permissions) \n      // - search is coming from a remote user (always!!!) \n      // - checking \"permission functions\" to determine what data to share \n      // - should already have created the AuthUser (in the universe.responsesCache) and other relevant permission information \n      \n      \n      // get all base (no nodeId) Nodes .... actually, get ALLLLLL Nodes! \n      // for each Node, run the permission functions \n      // - each child node (in the tree, go all the way down, recurse up!) \n      // after doing all child Nodes, do the parent Node \n      // - undefined means to leave it out \n      // - use universe.requestsCache for AuthUser, etc. \n      // after running all the permission functions, pass the Node to the parent \n      // return an array, without running any more analysis (do v2 locally) \n      \n      // permission functions are per-Node (stored as a type:permission_function that has a type:code as a NodeChild) \n      // permission functions are also per-Type, stored as a single Node for the type, of type:type_permission_function\n      \n      let startTime = (new Date()).getTime();\n      \n      let vmFuncCount = 0;\n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            // // type: NODE.type,\n            // nodeId: null,\n            active: true\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            \n            // action_pointer:0.0.1:local:238972ncr\n            \n            return new Promise((resolve, reject)=>{\n              // if(x==1){\n              //   resolve([{type:'FAKE'}]);\n              // }\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      \n      // loading all the PermissionNodes that are for method:read, cuz we'll repeatedly try each \n      let permissionFunctionNodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: \"permission_function:0.0.1:local:2387872h3f2\",\n            nodeId: null // top-level\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                return tmpNode.data.method == 'read';\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      permissionFunctionNodes = universe.lodash.sortBy(permissionFunctionNodes,funcNode=>{\n        let orderNode = universe.lodash.find(funcNode.nodes, {type: 'order_level:0.0.1:local:382hf273'});\n        return orderNode ? orderNode.data.level:0;\n      });\n      \n      let memoryTime = (new Date()).getTime();\n      \n      // await universe.historyLog({}, 'searching-internal-datasource2', 'debug')\n      \n      // return resolve({\n      //   nodes: nodes.length\n      // });\n      \n      let workGroup = (new Date()).getTime().toString(); // use this for concurrency\n      \n      let requestCache = await universe.getRequestCache({});\n      \n      // Instead of creating a bunch of small VMs to run...\n      // - assuming this container is OK \n      // - run analysis of the code snippets to make sure they are OK to run \n      // - use \"eval\" and create locally-accessible variables \n      // ....end result: exponentially faster \n      \n      \n      // Fetched all Nodes \n      // - iterate over nodes \n      let returnNodes = [];\n      let promises = [];\n      // for(let node of nodes){\n      nodes.forEach(node=>{\n        \n        promises.push(new Promise(async (resolve,reject)=>{\n          \n          // if node is undefined now, continue to the next one\n          if(!node){\n            // continue;\n            return resolve();\n          }\n          \n          \n          // returnNodes.push(node);\n          // return resolve();\n          \n          // Get all General PermissionFunctions \n          // - iterate through each \n          // - most will simply say \"i'm not concerned with this NodeType/Scenario\" \n          // - ordering by the \"type:order_level ChildNode\" \n          let returnedMoreThanPassThrough = false;\n          for(let funcNode of permissionFunctionNodes){\n            if(!node){\n              // skipping more permissionFunctions cuz already denied! \n              continue;\n            }\n            \n            // each permissionFunction can return 1 of 3 things: \n            // - true: if had no effect/match, passed-through \n            // - object: aka \"specifically allowed\" - passed permission function, potentially modified object on pass-through  \n            // - undefined: not allowed \n            \n            let codeNode = universe.lodash.find(funcNode.nodes, {type: 'code:0.0.1:local:32498h32f2'});\n            let simpleCompareNode = universe.lodash.find(funcNode.nodes, {type: 'simple_compare:0.0.1:local:298fy38y283'});\n            \n            let strFunc;\n            let permissionResult;\n            try {\n              \n              // permissionResult = await universe.runNodeCodeInVM({\n              //   codeNode, // includes type/schemaName and data.code\n              //   dataNode: node, // should be another Node that can be used by the action! \n              //   // timeout: 5000\n              //   workGroup,\n              //   workers: 10\n              // });\n              \n              \n              vmFuncCount++;\n              // permissionResult = await universe.runNodeCodeInVMSimple({\n              //   codeNode: simpleCompareNode, // includes type/schemaName and data.code\n              //   dataNode: {\n              //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              //     data: {\n              //       inputNode: node, // should be another Node that can be used by the action! \n              //       requestCache \n              //     }\n              //   }\n              // });\n              \n              strFunc = simpleCompareNode.data.code;\n              let INPUT = {\n                type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n                data: {\n                  inputNode: node,\n                  requestCache\n                }\n              }\n              let miniverse = {\n                lodash: universe.lodash\n              }\n              // console.log('strFunc:',strFunc.length);\n              permissionResult = eval(strFunc); // can't use Function cuz loses local scope\n              permissionResult = await Promise.resolve(permissionResult)\n              \n            }catch(err){\n              // return resolve('FAILED code from incoming_web_request');\n              permissionResult = undefined;\n              console.error('Failed in code from permission_function',err, strFunc);\n            }\n            \n            // await universe.historyLog({typeofp: (typeof permissionResult), permissionResult}, 'permission_result', 'debug')\n        \n            switch(typeof permissionResult){\n              case 'boolean':\n                if(!permissionResult){\n                  node = undefined;\n                }\n                break;\n                \n              case 'object':\n                returnedMoreThanPassThrough = true;\n                node = permissionResult;\n                break;\n                \n              default:\n                // result was undefined,null,etc.\n                node = undefined;\n                break;\n            }\n            \n          }\n          \n          // ...finished permissionFunctions \n          \n          if(!node){\n            // process next node \n            // continue;\n            return resolve();\n          }\n          \n          // if all the results are \"true\" (aka only did pass-through) then DENY! \n          // - defaulting to \"don't show shit\" :) \n          if(!returnedMoreThanPassThrough){\n            // continue;\n            return resolve();\n          }\n          \n          \n          returnNodes.push(node);\n          return resolve();\n          \n          // permission functions should also be adding to the \"permissionQueue\" \n          // - make it easier to say \"if I passed X permission, then ignore this thing\" \n          // - kinda already there by default: could modify the request keyValue store and stack? \n          //   - but not able to do that from miniverse...race condition for \"next\" permissionFunction? \n          \n          // permission_function:0.0.1:local:2387872h3f2\n          \n          \n          // Get permissionFunctions for this NodeType \n          // - fetch first single Node that has type:permission_function_for_type (or use \"has common_name:permission_function\"??) \n          \n          // Get final \"global\" permissionFunction \n          // - per-user? \n          // - what other permission functions should run? \n          \n          \n        }));\n        \n        \n      });\n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource3 (got return nodes)', 'debug')\n      \n      Promise.all(promises)\n      .then(async ()=>{\n        \n        console.log('vmFuncCountSetup:', vmFuncCount);\n      \n        // after we determine what a user is allowed to see...\n        // - manipulate === see !! (dont pretend that keeping things hidden here prevents what a user can output) \n        // - could easily say \"match Nodes that have X\" and even though we hide X, they know it exists cuz the ParentNode comes back \n        \n        // pass resulting Node to user's provided MatchFunction to see if this is a Node they want returned \n        // - their function also handles the amount of data they want to receive (any Children, etc.) \n        // - returning undefined means they DO NOT want it included \n        \n        let middleTime = (new Date()).getTime();\n        \n        let finalReturnNodes = [];\n        for(let node of returnNodes){\n          \n          let transformedResult;\n          let strFunc = INPUT.data.matchFunctionNode.data.code;\n          \n          try {\n            // vmFuncCount++;\n            // transformedResult = await universe.runNodeCodeInVMSimple({\n            //   codeNode: INPUT.data.matchFunctionNode, // includes type/schemaName and data.code\n            //   dataNode: {\n            //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n            //     data: {\n            //       inputNode: node, // should be another Node that can be used by the action! \n            //       // requestCache \n            //     }\n            //   }\n            //   // timeout: 5000\n            // });\n            \n            let INPUT = {\n              type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              data: {\n                inputNode: node,\n                // requestCache\n              }\n            }\n            let miniverse = {\n              lodash: universe.lodash\n            }\n            // console.log('strFunc:',strFunc.length);\n            transformedResult = eval(strFunc); // can't use Function cuz loses local scope\n            transformedResult = await Promise.resolve(transformedResult)\n          }catch(err){\n            // return resolve('FAILED code from incoming_web_request');\n            transformedResult = undefined;\n            console.error('Failed user function:', err);\n          }\n          \n          if(transformedResult){\n            finalReturnNodes.push(transformedResult);\n          }\n          \n        }\n        \n        \n        let endTime = (new Date()).getTime();\n        \n//         universe.console.log(`\n// Internal Search Times: \n// total: ${(endTime - startTime)/1000}\n// searchMemorySetup: ${(memoryTime - startTime)/1000}\n// internalSetup: (${nodes.length}) ${(middleTime - memoryTime)/1000}\n// userFuncs: (${returnNodes.length}) ${(endTime - middleTime)/1000}\n// vmFuncCount: ${vmFuncCount}\n//         `);\n            \n        resolve({\n          type: 'list_of_nodes:0.0.1:local:3289f2',\n          data: finalReturnNodes\n        });\n        \n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","key":"7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"},"active":true,"createdAt":1512531568518,"updatedAt":1513197225891,"parent":{"_id":"5a27666c9bd7021a55d5bdff","nodeId":"5a2507a1814a49f7ca157ced","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629},"nodes":[]},{"_id":"5a2766729bd7021a55d5be30","nodeId":"5a27666c9bd7021a55d5bdff","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: search internal datasource (people searching my data) Nodes"},"active":true,"createdAt":1512531570724,"updatedAt":null,"parent":{"_id":"5a27666c9bd7021a55d5bdff","nodeId":"5a2507a1814a49f7ca157ced","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629},"nodes":[]},{"_id":"5a2766749bd7021a55d5be42","nodeId":"5a27666c9bd7021a55d5bdff","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512531572710,"updatedAt":null,"parent":{"_id":"5a27666c9bd7021a55d5bdff","nodeId":"5a2507a1814a49f7ca157ced","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629},"nodes":[]},{"_id":"5a2766769bd7021a55d5be53","nodeId":"5a27666c9bd7021a55d5bdff","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531574277,"updatedAt":null,"parent":{"_id":"5a27666c9bd7021a55d5bdff","nodeId":"5a2507a1814a49f7ca157ced","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1512531564121,"updatedAt":1512531590629},"nodes":[]}]},{"_id":"5a2766a89bd7021a55d5be7c","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1512531624762,"updatedAt":1512531663488,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2766ab9bd7021a55d5be8d","nodeId":"5a2766a89bd7021a55d5be7c","type":"order_level:0.0.1:local:382hf273","data":{"level":1000},"active":true,"createdAt":1512531627962,"updatedAt":null,"parent":{"_id":"5a2766a89bd7021a55d5be7c","nodeId":"5a2507a1814a49f7ca157ced","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1512531624762,"updatedAt":1512531663488},"nodes":[]},{"_id":"5a2766ad9bd7021a55d5be9e","nodeId":"5a2766a89bd7021a55d5be7c","type":"simple_compare:0.0.1:local:298fy38y283","data":{"code":"(()=>{\n  \n  // has childNode of correct type! \n  return INPUT.data.inputNode;\n  \n})()"},"active":true,"createdAt":1512531629453,"updatedAt":null,"parent":{"_id":"5a2766a89bd7021a55d5be7c","nodeId":"5a2507a1814a49f7ca157ced","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1512531624762,"updatedAt":1512531663488},"nodes":[{"_id":"5a2766ae9bd7021a55d5bead","nodeId":"5a2766ad9bd7021a55d5be9e","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ALLOWING EVERYTHING!"},"active":true,"createdAt":1512531630828,"updatedAt":null,"parent":{"_id":"5a2766ad9bd7021a55d5be9e","nodeId":"5a2766a89bd7021a55d5be7c","type":"simple_compare:0.0.1:local:298fy38y283","data":{"code":"(()=>{\n  \n  // has childNode of correct type! \n  return INPUT.data.inputNode;\n  \n})()"},"active":true,"createdAt":1512531629453,"updatedAt":null},"nodes":[]}]},{"_id":"5a2766b09bd7021a55d5bebe","nodeId":"5a2766a89bd7021a55d5be7c","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512531632137,"updatedAt":null,"parent":{"_id":"5a2766a89bd7021a55d5be7c","nodeId":"5a2507a1814a49f7ca157ced","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1512531624762,"updatedAt":1512531663488},"nodes":[]}]},{"_id":"5a29b1de383ecc472906779e","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512681950153,"updatedAt":1512681974942,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a29b1df383ecc47290677af","nodeId":"5a29b1de383ecc472906779e","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action:0.0.1:local:2398y294c23"},"active":true,"createdAt":1512681951319,"updatedAt":null,"parent":{"_id":"5a29b1de383ecc472906779e","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512681950153,"updatedAt":1512681974942},"nodes":[]},{"_id":"5a29b1e0383ecc47290677c0","nodeId":"5a29b1de383ecc472906779e","type":"code:0.0.1:local:32498h32f2","data":{"key":"a821e596-0a28-4b2f-98f7-0211c636e475","code":"(()=>{\n  \n  // This code handles an incoming \"run_action...\"\n  // - finds possible actions, passes action data in! \n  \n  // can use SELF node to check for CodeSchema of Pointer (or adject/sibling CodeSchema if I have a ParentNode/nodeId?)! \n  // - to find my own Child nodes! \n  \n  // find \"INPUT.data.matchActionType\" \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      let x = 1; // this IS available in the filterNode function below!? \n      \n      let nodes = await universe.searchMemory({\n        filter: {\n          // sqlFilter: {\n          //   type: INPUT.type,\n          // },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                // see if has a ChildNode matching a type \n                \n                // // must match action type \n                // if(tmpNode.type != INPUT.data.matchActionType){\n                //   return false;\n                // }\n                // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                //   return false;\n                // }\n                \n                // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                //   return false;\n                // }\n                \n                if(tmpNode.type != INPUT.data.matchActionType){\n                  return false;\n                }\n                // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                \n                // // must have code to run! \n                // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                // });\n                \n                // if(!foundChildCode){\n                //   return false;\n                // }\n                \n                return true;\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      // return resolve({\n      //   test: 'ok',\n      //   typeMatch: INPUT.data.matchActionType,\n      //   nodes,\n      //   INPUT,\n      //   SELF\n      // });\n      \n      if(nodes && nodes.length){\n        // found Node to run for action! \n        // - assuming only 1 piece of Code possible/available \n        \n        let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n        \n        // run in vm, and pass in the inputSchema Node! \n        // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n        let actionResult;\n        try {\n          actionResult = await universe.runNodeCodeInVM({\n            codeNode, // includes type/schemaName and data \n            dataNode: INPUT.data.dataForAction, // should be another Node that can be used by the action! \n            timeout: 5000\n          });\n        }catch(err){\n          return resolve('FAILED action');\n        }\n        \n        // validate actionResult!\n        // - todo\n        \n        return resolve(actionResult);\n        // { \n        //   txt: 'Response:', \n        //   nodeTypes: nodes.map(n=>n.type),\n        //   actionResult\n        // }); // + result);\n        \n      } else {\n        // no Node found for handling action :( \n          \n        return resolve({ \n          error: 'No Nodes for action in run_action (1):',\n          action: INPUT.data.matchActionType\n        }); // + result);\n      }\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1512681952923,"updatedAt":1513150356091,"parent":{"_id":"5a29b1de383ecc472906779e","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512681950153,"updatedAt":1512681974942},"nodes":[]},{"_id":"5a29b1e2383ecc47290677d1","nodeId":"5a29b1de383ecc472906779e","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action call handler!"},"active":true,"createdAt":1512681954204,"updatedAt":null,"parent":{"_id":"5a29b1de383ecc472906779e","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512681950153,"updatedAt":1512681974942},"nodes":[]},{"_id":"5a29b1e3383ecc47290677e0","nodeId":"5a29b1de383ecc472906779e","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512681955836,"updatedAt":null,"parent":{"_id":"5a29b1de383ecc472906779e","nodeId":"5a2507a1814a49f7ca157ced","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1512681950153,"updatedAt":1512681974942},"nodes":[]}]},{"_id":"5a29e4bb678d2b5052fba831","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a29e4bd678d2b5052fba842","nodeId":"5a29e4bb678d2b5052fba831","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512694973212,"updatedAt":null,"parent":{"_id":"5a29e4bb678d2b5052fba831","nodeId":"5a2507a1814a49f7ca157ced","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216},"nodes":[]},{"_id":"5a29e4bf678d2b5052fba853","nodeId":"5a29e4bb678d2b5052fba831","type":"code:0.0.1:local:32498h32f2","data":{"key":"267e87c1-8497-4eeb-8af6-4e50e0098a6f","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // todo: make a request to a remote Second to be taught something \n      // - \"i want to learn about X\" \n      \n      let saved;\n      try {\n        saved = await universe.updateNode(INPUT.data);\n        saved = {\n          type: 'saved_node:...',\n          data: saved\n        }\n      }catch(err){\n        saved = {\n          type: 'error_failed_saving:...',\n          data: {\n            error: true,\n            err: err.toString()\n          }\n        }\n      }\n      \n      resolve({\n        saved,\n        INPUT\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512694975026,"updatedAt":1513150359820,"parent":{"_id":"5a29e4bb678d2b5052fba831","nodeId":"5a2507a1814a49f7ca157ced","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216},"nodes":[]},{"_id":"5a29e4c0678d2b5052fba864","nodeId":"5a29e4bb678d2b5052fba831","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: update a Node by passing in the new Node"},"active":true,"createdAt":1512694976766,"updatedAt":null,"parent":{"_id":"5a29e4bb678d2b5052fba831","nodeId":"5a2507a1814a49f7ca157ced","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216},"nodes":[]},{"_id":"5a29e4c2678d2b5052fba873","nodeId":"5a29e4bb678d2b5052fba831","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512694978327,"updatedAt":null,"parent":{"_id":"5a29e4bb678d2b5052fba831","nodeId":"5a2507a1814a49f7ca157ced","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216},"nodes":[]},{"_id":"5a29e4c3678d2b5052fba884","nodeId":"5a29e4bb678d2b5052fba831","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512694979740,"updatedAt":null,"parent":{"_id":"5a29e4bb678d2b5052fba831","nodeId":"5a2507a1814a49f7ca157ced","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1512694971602,"updatedAt":1512695048216},"nodes":[]}]},{"_id":"5a29e4e8678d2b5052fba8a0","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695016250,"updatedAt":1512695040235,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a29e4e9678d2b5052fba8b1","nodeId":"5a29e4e8678d2b5052fba8a0","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512695017672,"updatedAt":null,"parent":{"_id":"5a29e4e8678d2b5052fba8a0","nodeId":"5a2507a1814a49f7ca157ced","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695016250,"updatedAt":1512695040235},"nodes":[]},{"_id":"5a29e4eb678d2b5052fba8c1","nodeId":"5a29e4e8678d2b5052fba8a0","type":"code:0.0.1:local:32498h32f2","data":{"key":"c9825374-18ab-414e-bad3-011830343c74","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      let { optionsNode, dataNode } = INPUT.data;\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: dataNode.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: dataNode.type,\n        nodeId: dataNode.nodeId,\n        data: dataNode.data\n      }\n      \n      if(nodes.length && !optionsNode.data.skipExistingLearnedNodeId){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      // - this should be an option, passed as a Node (instead of having INPUT as the Node!) \n      let savedNodeChild;\n      if(dataNode._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: dataNode._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        type: 'node:...',\n        data: savedNode,\n          // child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695019119,"updatedAt":1513150364671,"parent":{"_id":"5a29e4e8678d2b5052fba8a0","nodeId":"5a2507a1814a49f7ca157ced","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695016250,"updatedAt":1512695040235},"nodes":[]},{"_id":"5a29e4ec678d2b5052fba8d2","nodeId":"5a29e4e8678d2b5052fba8a0","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: forcing to learn a single new Node (handles nodeId and whatnot too!)"},"active":true,"createdAt":1512695020524,"updatedAt":null,"parent":{"_id":"5a29e4e8678d2b5052fba8a0","nodeId":"5a2507a1814a49f7ca157ced","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695016250,"updatedAt":1512695040235},"nodes":[]},{"_id":"5a29e4ed678d2b5052fba8e2","nodeId":"5a29e4e8678d2b5052fba8a0","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512695021753,"updatedAt":null,"parent":{"_id":"5a29e4e8678d2b5052fba8a0","nodeId":"5a2507a1814a49f7ca157ced","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1512695016250,"updatedAt":1512695040235},"nodes":[]}]},{"_id":"5a2af160c6a04152db10417c","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2af162c6a04152db10418c","nodeId":"5a2af160c6a04152db10417c","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1512763746350,"updatedAt":null,"parent":{"_id":"5a2af160c6a04152db10417c","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332},"nodes":[]},{"_id":"5a2af165c6a04152db10419d","nodeId":"5a2af160c6a04152db10417c","type":"code:0.0.1:local:32498h32f2","data":{"key":"04589537-9255-4026-92bd-8e3e9b7358d6","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Being passed in the publicKey we want to initiate a challenge with \n      // - also sending our \"connect_method\" info (if it exists) \n      \n      \n      // INPUT.type == \"challenge_init_remote:0.0.1:...\"\n      // INPUT.data == { \n      //   ExternalIdentityNode: { data: {publicKey:Strig}, nodes: [connect_method] }\n      // }\n      \n      // Save ExternalIdentityNode locally! \n      // - required before Identifying \n      // - saveExternal *should* handle duplicates (and updating the initial AuthPassphrase) \n      let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'saveExternal',\n          options: {\n            ExternalIdentityNode: INPUT.data.ExternalIdentityNode // should contain a connection method! \n          }\n        }\n      });\n      \n      console.log('Saved new/updated ExternalIdentityNode', ExternalIdentityNode);\n      \n      \n      // Authenticate with External Second \n      // - make authenticated requests to a Second (necessary for Learning?) \n      //   - should have ALL requests authenticated \n      // universe.setupExternalSecond();\n      let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'start',\n          options: {\n            externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n            // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          }\n        }\n      });\n      \n      return resolve({\n        ExternalIdentityNode,\n        authExternalIdentityNode\n      })\n      \n      // // return resolve({\n      // //   msg: 'Being asked to auth with a remote!',\n      // //   INPUT\n      // // });\n      \n      \n      \n      // // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // // INPUT: \n      // // {\n      // //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      // //   data: 'string'\n      // // }\n      \n      \n      // // Initiates a challenge with an external Second \n      // // - ExternalIdentity should ALREADY EXIST locally! \n      // //   - look it up from nodes by INPUT.data.publicKey \n      // // - lookup by data:publicKey, childNode:type:connect_method \n      // // - checks for local ExternalIdentity first! \n      // // - \n      \n      // // return resolve({\n      // //   INPUT\n      // // });\n      \n      \n      // // Get local ExternalIdentity if it exists \n      // let nodes = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       type: 'external_identity:0.0.1:local:8982f982j92',\n      //       data: {\n      //         publicKey: INPUT.data\n      //       }\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       return tmpNodes;\n      //     }\n      //   }\n      // });\n      \n      // if(!nodes.length){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity node',\n      //       publicKey: INPUT.data\n      //     }\n      //   })\n      // }\n      \n      // let ExternalIdentityNode = nodes[0];\n      // // else {\n      // //   ExternalIdentityNode = {\n      // //     // no _id yet! (will create/update later!) \n      // //     type: 'external_identity:0.0.1:local:8982f982j92',\n      // //     data: {\n      // //       publicKey:INPUT.data\n      // //     }\n      // //   }\n      // // }\n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // // Initiate Auth Steps \n      // // - send my publicKey, new challengeText that we want validated \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      // universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // // make Node request to datasource\n      // let InitiateIdentifyNode = {\n      //   type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challenge: newChallenge\n      //   }\n      // }\n      // let WrappedInitiateIdentifyNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n      //     dataForAction: InitiateIdentifyNode\n      //   }\n      // }\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      // // response includes the \"output_generic\" wrapper \n      // let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // // successful response: challenge_start_response\n      // // return resolve({\n      // //   ok: 'test1',\n      // //   response: ExternalInitialResponse\n      // // });\n      \n      // // Received:\n      // // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // // - \n      \n      \n      // // Verify challenge I sent \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // // boolean Node is returned\n      // if(!verified.data){\n      //   return resolve({\n      //     err: 'Failed verifiation!',\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   });\n      // }\n      \n      \n      // // return resolve({\n      // //   verified: verified\n      // // });\n      \n      \n      // // Verified external! \n      // // - now need to identify myself, by answering the challenge I was sent \n      // // - really this could be completed in reverse (but might as well just do it here!) \n      // //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      \n      // // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // // - getting a JWT back! \n      // let GetIdentityTokenNode = {\n      //   type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challengeReceived: ExternalInitialResponseNode.data.challenge,\n      //     solution: SignedNode.data // base64 string \n      //   }\n      // }\n      // let WrappedTokenNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n      //     dataForAction: GetIdentityTokenNode\n      //   }\n      // }\n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // // return resolve({\n      // //   x: 1,\n      // //   ExternalTokenResponseFull\n      // // });\n      \n      // // response includes the \"output_generic\" wrapper \n      // let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // // save updated ExternalIdentityNode\n      // ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      // let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // // todo: save\n      \n      // // check for publicKey info (ok to allow this person?) \n      // // - after I send them something to sign and actually get their identity...\n      \n      // resolve({\n      //   type: 'challenge_finish:0.0.1:local:2983jf982',\n      //   data: {\n      //     SUCCESS: {\n      //       ExternalInitialResponseNode,\n      //       ExternalTokenResponseNode,\n      //       SignedNode_data: SignedNode.data,\n      //       updatedExternalIdentityNode\n      //     }\n      //   }\n      // });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1512763749724,"updatedAt":1513150380871,"parent":{"_id":"5a2af160c6a04152db10417c","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332},"nodes":[]},{"_id":"5a2af167c6a04152db1041ad","nodeId":"5a2af160c6a04152db10417c","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: initiate an external connection (act as Client)"},"active":true,"createdAt":1512763751328,"updatedAt":null,"parent":{"_id":"5a2af160c6a04152db10417c","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332},"nodes":[]},{"_id":"5a2af169c6a04152db1041be","nodeId":"5a2af160c6a04152db10417c","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512763753160,"updatedAt":null,"parent":{"_id":"5a2af160c6a04152db10417c","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332},"nodes":[]},{"_id":"5a2af16bc6a04152db1041cf","nodeId":"5a2af160c6a04152db10417c","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1512763755570,"updatedAt":null,"parent":{"_id":"5a2af160c6a04152db10417c","nodeId":"5a2507a1814a49f7ca157ced","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1512763744940,"updatedAt":1512763773332},"nodes":[]}]},{"_id":"5a2dc22b433ce00bc84b0568","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1512948267563,"updatedAt":1512948318782,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2dc22d433ce00bc84b0580","nodeId":"5a2dc22b433ce00bc84b0568","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: take a request and search a remote datasource. Does NOT reduce the query at all (that would be handled in a more complex Action type:search_datasources_and_reduce)"},"active":true,"createdAt":1512948269354,"updatedAt":null,"parent":{"_id":"5a2dc22b433ce00bc84b0568","nodeId":"5a2507a1814a49f7ca157ced","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1512948267563,"updatedAt":1512948318782},"nodes":[]},{"_id":"5a2dc22f433ce00bc84b0598","nodeId":"5a2dc22b433ce00bc84b0568","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1512948271998,"updatedAt":null,"parent":{"_id":"5a2dc22b433ce00bc84b0568","nodeId":"5a2507a1814a49f7ca157ced","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1512948267563,"updatedAt":1512948318782},"nodes":[]},{"_id":"5a2dc233433ce00bc84b05b5","nodeId":"5a2dc22b433ce00bc84b0568","type":"code:0.0.1:local:32498h32f2","data":{"key":"142170be-9d26-4858-8ed6-dffa875fef96","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Get my token for the remote datasource \n      \n      let nodeId = INPUT.data.internalId;\n      let publicKey = INPUT.data.publicKey;\n      \n      // Get local ExternalIdentity if it exists \n      // - should exist, unless we deleted it! \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            _id: nodeId,\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            // data: {\n            //   publicKey: publicKey\n            // }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes || !nodes.length){\n        \n        return resolve({\n          type: 'error:..',\n          data: {\n            msg: 'No ExternalIdentityNode when finding'\n          }\n        });\n        \n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      let token = ExternalIdentityNode.data.token;\n      \n      // ExternalIdentityNode.data.test1 = 'test1';\n      // let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      \n      // return resolve({\n      //   ExternalIdentityNode,\n      //   token\n      // })\n      // let token = await universe.capabilities().\n      // run_action_sequence:0.0.1:local:293fh8239hsdf23f\n      \n                \n      let data = {\n        type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n        data: {\n          actions: [\n            \n            {\n              matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              dataForAction: {\n                type: 'string:...',\n                data: token\n              }\n            }\n                    \n            // {\n            //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n            //   dataForAction: {\n            //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n            //     data: {\n            //       matchFunctionNode: {\n            //         // query here!\n            //         // action_pointer:0.0.1:local:238972ncr\n            //         type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n            //         data: {\n            //           code: `(()=>{\n            //             // Action \n            //             // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n    \n            //             let inputNode = INPUT.data.inputNode;\n    \n            //             let actionSearch = {\n            //               type: 'action_pointer:0.0.1:local:238972ncr', // should use \"common_type\" ?? \n            //             }\n            //             let hasActionPointerChild = miniverse.lodash.find(inputNode.nodes, actionSearch);\n    \n            //             if(!hasActionPointerChild){\n            //               return false;\n            //             }\n    \n            //             // strip childnodes\n            //             delete inputNode.nodes;\n            //             // delete inputNode.parent;\n            //             delete inputNode.data;\n    \n            //             return inputNode;\n            //           })()`\n            //         }\n            //       },\n            //       // expected/allowed schemas for return \n            //       outputSchemas: [\n            //         'query_result:0.0.1:local:32490usfj23o23f',\n            //         'internal_error_output:0.0.1:local:32948x2u3cno2c'\n            //       ]\n            //     }\n            //   }\n            // }\n          \n          ]\n        }\n      }\n      let response;\n      try {\n        response = await universe.webrequest.post({\n          url: 'http://localhost:7005/ai',\n          // url: 'http://google.com',\n          body: data,\n          json: true\n        });\n      }catch(err){\n        return resolve({\n          error: true,\n          err,\n          errStr: err.toString()\n        });\n      }\n      \n      resolve({\n        remoteResponse: response\n      });\n    }catch(err){\n      reject(err);\n    }\n  })\n})()"},"active":true,"createdAt":1512948275403,"updatedAt":1513150384302,"parent":{"_id":"5a2dc22b433ce00bc84b0568","nodeId":"5a2507a1814a49f7ca157ced","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1512948267563,"updatedAt":1512948318782},"nodes":[]}]},{"_id":"5a2f2c794656092981e5fca4","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2f2c7c4656092981e5fca7","nodeId":"5a2f2c794656092981e5fca4","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513041020956,"updatedAt":null,"parent":{"_id":"5a2f2c794656092981e5fca4","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958},"nodes":[]},{"_id":"5a2f2c7f4656092981e5fcaa","nodeId":"5a2f2c794656092981e5fca4","type":"code:0.0.1:local:32498h32f2","data":{"key":"63c8bfa5-289b-4d8b-b8f5-6e8908fd1ac2","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n      //   data: {\n      //     fileName: String,\n      //     fileType: String\n      //   }\n      // }\n      \n      \n      try {\n        \n        universe.console.log('Getting SignedUrlNode1');\n        \n        let SignedUrlNode = await universe.loadAndRunCapability('File',{},{\n          type: 'standard_capability_action:0.0.1:local:298j291bs',\n          data: {\n            action: 'signUpload',\n            options: {\n              type: '...',\n              data: INPUT.data\n            }\n          }\n        });\n        \n        \n        universe.console.log('Getting SignedUrlNode2');\n        \n        return resolve({\n          type: 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd',\n          data: SignedUrlNode.data\n        });\n        \n      }catch(err){\n        console.error('FAILED File.signUpload',err);\n        \n        return resolve({\n          // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed File.signUpload',\n            INPUT,\n            error: true,\n            err: err\n          }\n        });\n        \n      }\n      \n      // try {\n          \n      //   const s3 = new universe.aws.S3();\n      //   const fileName = INPUT.data.fileName;\n      //   const fileType = INPUT.data.fileType;\n      //   const s3Params = {\n      //     Bucket: universe.env.S3_BUCKET,\n      //     Key: fileName,\n      //     Expires: 60,\n      //     ContentType: fileType,\n      //     // ACL: 'public-read'\n      //     ACL: 'private'\n      //   };\n      \n      //   s3.getSignedUrl('putObject', s3Params, (err, data) => {\n      //     if(err){\n      //       universe.console.log('aws error:', err);\n                \n      //       return resolve({\n      //         // savedNode\n      //         type: 'error2:..',\n      //         data: {\n      //           INPUT,\n      //           error: true,\n      //           err: err.toString()\n      //         }\n      //       });\n      //       // return res.end();\n      //     }\n      //     const returnData = {\n      //       signedRequest: data,\n      //       url: `https://${universe.env.S3_BUCKET}.s3.amazonaws.com/${fileName}`\n      //     };\n      //     // res.write(JSON.stringify(returnData));\n      //     // res.end();\n            \n      //     return resolve({\n      //       type: 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd',\n      //       data: returnData\n      //     });\n          \n      //   });\n        \n        \n      // }catch(err){\n      //   return resolve({\n      //     // savedNode\n      //     type: 'error:..',\n      //     data: {\n      //       INPUT,\n      //       error: true,\n      //       err: err.toString()\n      //     }\n      //   });\n      // }\n      \n      \n      \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513041023606,"updatedAt":1513150401080,"parent":{"_id":"5a2f2c794656092981e5fca4","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958},"nodes":[]},{"_id":"5a2f2c814656092981e5fcad","nodeId":"5a2f2c794656092981e5fca4","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: return a token for uploading a file to S3"},"active":true,"createdAt":1513041025219,"updatedAt":null,"parent":{"_id":"5a2f2c794656092981e5fca4","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958},"nodes":[]},{"_id":"5a2f2c844656092981e5fcb0","nodeId":"5a2f2c794656092981e5fca4","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513041028446,"updatedAt":null,"parent":{"_id":"5a2f2c794656092981e5fca4","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958},"nodes":[]},{"_id":"5a2f2c874656092981e5fcb3","nodeId":"5a2f2c794656092981e5fca4","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513041031682,"updatedAt":null,"parent":{"_id":"5a2f2c794656092981e5fca4","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513041017221,"updatedAt":1513041075958},"nodes":[]}]},{"_id":"5a2f2cbe4656092981e5fcbd","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2f2cc04656092981e5fcc0","nodeId":"5a2f2cbe4656092981e5fcbd","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513041088871,"updatedAt":null,"parent":{"_id":"5a2f2cbe4656092981e5fcbd","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413},"nodes":[]},{"_id":"5a2f2cc64656092981e5fcc4","nodeId":"5a2f2cbe4656092981e5fcbd","type":"code:0.0.1:local:32498h32f2","data":{"key":"096ef003-9e52-4f4c-8d84-3a38d71088a7","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n      //   data: {\n      //     key: String,\n      //   }\n      // }\n      \n      try {\n        let SignedUrlNode = await universe.loadAndRunCapability('File',{},{\n          type: 'standard_capability_action:0.0.1:local:298j291bs',\n          data: {\n            action: 'signGet',\n            options: {\n              type: '...',\n              data: {\n                key: INPUT.data.key\n              }\n            }\n          }\n        });\n        \n        return resolve({\n          type: 'request_file_get_response:0.0.1:local:902jf908j139001',\n          data: SignedUrlNode.data\n        });\n        \n      }catch(err){\n        console.error('FAILED File.signGet',err);\n        \n        return resolve({\n          // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed File.signGet',\n            INPUT,\n            error: true,\n            err: err.toString()\n          }\n        });\n        \n      }\n      \n      \n      \n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513041094453,"updatedAt":1513150406642,"parent":{"_id":"5a2f2cbe4656092981e5fcbd","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413},"nodes":[]},{"_id":"5a2f2cc94656092981e5fcc8","nodeId":"5a2f2cbe4656092981e5fcbd","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: return a signed url to download a file from s3"},"active":true,"createdAt":1513041097339,"updatedAt":null,"parent":{"_id":"5a2f2cbe4656092981e5fcbd","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413},"nodes":[]},{"_id":"5a2f2cd14656092981e5fccf","nodeId":"5a2f2cbe4656092981e5fcbd","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513041105817,"updatedAt":null,"parent":{"_id":"5a2f2cbe4656092981e5fcbd","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413},"nodes":[]},{"_id":"5a2f2cd74656092981e5fcd5","nodeId":"5a2f2cbe4656092981e5fcbd","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513041111459,"updatedAt":null,"parent":{"_id":"5a2f2cbe4656092981e5fcbd","nodeId":"5a2507a1814a49f7ca157ced","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513041086968,"updatedAt":1513041123413},"nodes":[]}]},{"_id":"5a2f2cc84656092981e5fcc6","type":"capability:0.0.1:local:187h78h23","data":{"key":"File","version":"1.0.0"},"active":true,"createdAt":1513041096286,"updatedAt":1513041131903,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[{"_id":"5a2f2ccf4656092981e5fccc","nodeId":"5a2f2cc84656092981e5fcc6","type":"code:0.0.1:local:32498h32f2","data":{"key":"18758d2d-4380-4475-b694-15290a223074","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      const s3 = new universe.aws.S3();\n      \n      console.log('Loaded Capability: File');\n            \n      switch(inputAction){\n        case 'signUpload':\n          \n          // inputOpts: {\n          //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n          //   data: {\n          //     fileName: String,\n          //     fileType: String\n          //   }\n          // }\n            \n          try {\n              \n            // const fileName = inputOpts.data.fileName; // keep file extensions? \n            const fileName = universe.uuidv4(); // + '.png';\n            \n            const fileType = inputOpts.data.fileType;\n            const s3Params = {\n              Bucket: universe.env.S3_BUCKET,\n              Key: fileName,\n              Expires: 60,\n              ContentType: fileType,\n              // ACL: 'public-read'\n              ACL: 'private'\n            };\n          \n            s3.getSignedUrl('putObject', s3Params, (err, data) => {\n              \n              if(err){\n                universe.console.log('aws error:', err);\n                    \n                return resolve({\n                  // savedNode\n                  type: 'error2:..',\n                  data: {\n                    inputOpts,\n                    error: true,\n                    err: err\n                  }\n                });\n                // return res.end();\n              }\n              \n              const returnData = {\n                signedRequest: data,\n                url: `https://${universe.env.S3_BUCKET}.s3.amazonaws.com/${fileName}`,\n                key: fileName\n              };\n              // res.write(JSON.stringify(returnData));\n              // res.end();\n              \n              return resolve({\n                type: 'sign_upload_response:0.0.1:local:2891785cvw',\n                data: returnData\n              });\n              \n            });\n            \n          }catch(err){\n            console.error('SIGN ERROR!');\n            return resolve({\n              // savedNode\n              type: 'error:..',\n              data: {\n                msg: 'failed sign_upload',\n                INPUT,\n                error: true,\n                err: err\n              }\n            });\n          }\n          break;\n        \n        case 'signGet':\n        \n          // inputOpts: {\n          //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n          //   data: {\n          //     key: String,\n          //   }\n          // }\n            \n          try {\n            \n            universe.console.log('Capability: signGet');\n            \n            const myBucket = universe.env.S3_BUCKET;\n            const myKey = inputOpts.data.key;\n            const signedUrlExpireSeconds = 60 * 1; // 1 minutes\n            \n            const signedUrl = s3.getSignedUrl('getObject', {\n                Bucket: myBucket,\n                Key: myKey,\n                Expires: signedUrlExpireSeconds\n            })\n            \n            universe.console.log('Capability: signGet DONE');\n            \n            return resolve({\n              type: 'sign_get_response:0.0.1:local:8923782hf87sdjkh6',\n              data: {\n                url: signedUrl\n              }\n            });\n            \n            \n          }catch(err){\n            return resolve({\n              // savedNode\n              type: 'error:..',\n              data: {\n                msg: 'failed sign_get',\n                INPUT,\n                error: true,\n                err: err\n              }\n            });\n          }\n          break;\n        \n        default:\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513041103001,"updatedAt":1513150410199,"parent":{"_id":"5a2f2cc84656092981e5fcc6","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"File","version":"1.0.0"},"active":true,"createdAt":1513041096286,"updatedAt":1513041131903},"nodes":[]},{"_id":"5a2f2cd54656092981e5fcd2","nodeId":"5a2f2cc84656092981e5fcc6","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: File"},"active":true,"createdAt":1513041109252,"updatedAt":null,"parent":{"_id":"5a2f2cc84656092981e5fcc6","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"File","version":"1.0.0"},"active":true,"createdAt":1513041096286,"updatedAt":1513041131903},"nodes":[]},{"_id":"5a2f2cdd4656092981e5fcd9","nodeId":"5a2f2cc84656092981e5fcc6","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513041117387,"updatedAt":null,"parent":{"_id":"5a2f2cc84656092981e5fcc6","nodeId":"5a2507a1814a49f7ca157ced","type":"capability:0.0.1:local:187h78h23","data":{"key":"File","version":"1.0.0"},"active":true,"createdAt":1513041096286,"updatedAt":1513041131903},"nodes":[]}]},{"_id":"5a30d0be59992145292cf623","type":"code:0.0.1:local:32498h32f2","data":{"key":"059b41f6-ed97-4c8c-b35e-c2b1218c81a1","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // This code is downloaded to a browser and run! \n      // - deletes all existing nodes\n      // - fetches all of the remote child nodes for a learning pointer\n      //   - using a \"run_action_sequence\" \n      \n      // Capabilities required: \n      // - TalkToSecond \n      // - NodeLobotomy (CRUD) \n      \n      \n      // Assuming the correct ExternalIdentityNode has been passed in as well! \n      // - could just have it in code, but might as well keep it external? \n      \n      // let IdentityNode = null;\n      // let identities = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       // this runs isolated, outside of the above context? (not sure) \n      //       return new Promise((resolve, reject)=>{\n      //         resolve(tmpNodes);\n      //       });\n      //     },\n      //   }\n      // });\n      \n      let appToGet;\n      try {\n        appToGet = WINDOW.prompt('App to use?','browser_developer');\n      }catch(err){\n        console.error('Not in Tab');\n        appToGet = 'browser_developer';\n      }\n      \n      let codeSearchTemplate = `(()=>{\n        // Action \n        // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n        \n        // type is props_for_vm\n        // inputNode is used by code_miniverse\n        let inputNode = INPUT.data.inputNode;\n        \n        if(inputNode.type != 'parent_of_nodes_to_learn:0.0.1:local:2839fh29'){\n          return null;\n        }\n        \n        if(inputNode.data.learn != '{{APP}}'){\n          return null;\n        }\n        \n        // strip childnodes\n        // delete inputNode.nodes; \n        // delete inputNode.parent;\n        delete inputNode.data;\n  \n        return inputNode;\n        \n      })()`\n      // console.log('codeSearchTemplate1', codeSearchTemplate);\n      codeSearchTemplate = codeSearchTemplate.split(\"{{APP}}\").join(appToGet)\n      // console.log('codeSearchTemplate2', codeSearchTemplate);\n      \n      // Get the node(s) to install \n      // - single node, with children \n      let nodeResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'send',\n          options: {\n            ExternalIdentityNode: INPUT,\n            RequestNode: {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                  {\n                    matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                    dataForAction: {\n                      type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                      data: {\n                        matchFunctionNode: {\n                          // query here!\n                          // action_pointer:0.0.1:local:238972ncr\n                          type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                          data: {\n                            code: codeSearchTemplate\n                          }\n                        },\n                        // expected/allowed schemas for return \n                        // outputSchemas: [\n                        //   'query_result:0.0.1:local:32490usfj23o23f',\n                        //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                        // ]\n                      }\n                    }\n                  }\n                ]\n                \n              }\n            }\n          }\n        }\n      });\n      \n      \n      // Keep our local Identity \n      // - cuz we're about to clear all the memory! \n      let myPrivateIdentity;\n      let identities = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'identity_private:0.0.1:local:3298f2j398233'\n          }\n        }\n      });\n      myPrivateIdentity = identities[0];\n      \n      // Clear existing nodes \n      await universe.clearMemory({});\n      \n      \n      // Force-write all new nodes \n      // - keeps nodeId correct for all children \n      // - todo: handle _id changes in \"data\" fields! \n      const saveChildNodes = (nodeId, childNodes) => {\n        return new Promise(async (resolve, reject)=>{\n\n          for(let tmpNode of childNodes){\n            let newChildNode = {\n              nodeId,\n              type: tmpNode.type,\n              data: tmpNode.data,\n            }\n            let savedChildNode = await universe.newNode(newChildNode);\n\n            if(tmpNode.nodes && tmpNode.nodes.length){\n\n              await saveChildNodes(savedChildNode._id, tmpNode.nodes);\n\n            }\n          }\n          resolve();\n        });\n      }\n      \n      \n      // Re-add my myPrivateIdentity \n      let savedPrivateIdentityNode = await universe.newNode(myPrivateIdentity);\n      await saveChildNodes(savedPrivateIdentityNode._id, myPrivateIdentity.nodes);\n          \n      // add all \"learned\" nodes \n      let parentNodesToLearn = nodeResponse.data.actionResponses[0].data;\n      for(let parentNode of parentNodesToLearn){\n        \n        for(let node of parentNode.nodes){\n          \n          // iterate\n          // - save this one, then start saving down tree\n          let newNode = {\n            nodeId: null,\n            type: node.type,\n            data: node.data,\n          }\n  \n          let savedNode = await universe.newNode(newNode);\n          await saveChildNodes(savedNode._id, node.nodes);\n        }\n      }\n      \n      // // Relearn Capabilities that are now available\n      // await universe.reloadCapabilities();\n      \n  \n      // // Run rsa capability \n      // let rsaCapNode = await universe.loadCapability('rsa');\n      // let keyNode = await universe.runCapability(rsaCapNode, {\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'new',\n      //     options: {b: 512}\n      //   }\n      // });\n      // try {\n      //   let keyNode = await universe.loadAndRunCapability('rsa',{},{\n      //     type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //     data: {\n      //       action: 'new',\n      //       options: {b: 512}\n      //     }\n      //   });\n        \n      //   keyNode.data.generateKeyPair(2048, 65537);\n      //   console.log('RSA Capability worked!', keyNode.data.exportKey('pkcs8-public-pem'));\n      // }catch(err){\n      //   console.error('FAILED RSA',err);\n      // }\n      \n      \n      // // Create a new Local Identity\n      // let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'createLocal',\n      //     options: {}\n      //   }\n      // });\n      \n      // console.log('newLocalIdentity:', newIdentityNode);\n      \n      // Identify with Remote \n      // - and setup to use that token going forward! \n      // let keyNode = await universe.loadAndRunCapability('rsa',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'new',\n      //     options: {b: 512}\n      //   }\n      // });\n      \n      \n      let allNodesAfterLearning = await universe.searchMemory({});\n      console.log('allNodesAfterLearning',allNodesAfterLearning);\n      \n      return resolve({\n        learned: true,\n        // nodesToLearn,\n        myPrivateIdentity\n      });\n      \n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","note":"learning pointer browser_developer"},"active":true,"createdAt":1513148606067,"updatedAt":1513150529644,"parent":{"_id":"5a2507a1814a49f7ca157ced","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"generic_cloud_second"},"active":true,"createdAt":1512376225825,"updatedAt":1512376322642},"nodes":[]}]