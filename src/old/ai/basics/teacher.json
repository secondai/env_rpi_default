[{"_id":"5a3085fb7e9fab3b612008fd","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1513129467223,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3085fb7e9fab3b612008fe","nodeId":"5a3085fb7e9fab3b612008fd","type":"code:0.0.1:local:32498h32f2","data":{"key":"42928ae7-692e-454b-bbd9-6b3c4191109d","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: generic_cloud_second \n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      // console.log('INPUT:', JSON.stringify(INPUT,null,2));\n      \n      \n      switch(INPUT.type){\n          \n        case 'incoming_first:0.1.1:local:78882h37':\n          \n          console.log('INCOMING FIRST!!');\n          \n          // INPUT is probably null \n          \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          console.log('newIdentityNode', JSON.stringify(newIdentityNode,null,2));\n          \n          \n          // STOPPING HERE! \n          // - not \"learning\" anything from remote, just using whatever is currently available (JSON-start)\n          \n          console.log('Created Identity on _first, Second all ready!');\n          \n          // Register Identity on remote \n          let registeredExternal = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'registerOnChain',\n              options: {\n                words: universe.env.STARTUP_REACHABLE_WORDS,\n                publicKey: newIdentityNode.data.public,\n                connection: newIdentityNode.nodes[0].data.connection\n              }\n            }\n          });\n          \n          \n          return resolve({\n            type: 'something2...',\n            data: {\n              createdIdentity: true,\n              registeredExternal\n              // WORDS: universe.env.STARTUP_REACHABLE_WORDS,\n              // publicKey: newIdentityNode.data.public,\n              // connection: newIdentityNode.nodes[0].data.connection\n            }\n          });\n          \n          \n          \n          \n          // // Find remote Second \n          // // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // // - want a publicKey and a URL returned \n          // //   - a whole IdentityNode should be returned? \n          // // - return: \n          // //   - external_identity:0.0.1:local:8982f982j92\n          // //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // let remoteValue;\n          // try {\n          //   remoteValue = 'test test'; //WINDOW.prompt('Remote Second','test test');\n          // }catch(err){\n          //   console.error('Not in Tab');\n          //   remoteValue = 'test test';\n          // }\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words: remoteValue\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // // fetch that wallet address, get the first transaction \n          // // - first transaction contains IPFS link \n          // // - IPFS contains Nodes (without _ids!) \n          // let ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          // // console.log('Got ExternalIdentityNode',ExternalIdentityNode);\n          \n          // // return resolve({\n          // //   ExternalIdentityNode,\n          // //   error: true,\n          // //   remoteValue,\n          // //   address\n          // // })\n          \n          // // return resolve({\n          // //   aboutToIdentity: true\n          // // });\n          \n          // // Authenticate with External Second \n          // // - make authenticated requests to a Second (necessary for Learning?) \n          // //   - should have ALL requests authenticated \n          // // universe.setupExternalSecond();\n          // let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'start',\n          //     options: {\n          //       externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n          //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          //     }\n          //   }\n          // });\n          \n          // console.log('FINISHED INITIATE!', authExternalIdentityNode);\n          \n          // // console.log('ExternalIdentityNode', JSON.stringify(ExternalIdentityNode,null,2));\n          \n          // // Connect to passed-in data (ExternalIdentityNode) \n          // // - run a search_internal_datasource action sequence to acquire the code to run \n          // // - run the code on local Second  \n          // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'send',\n          //     options: {\n          //       ExternalIdentityNode,\n          //       RequestNode: {\n          //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //         data: {\n          //           actions: [\n                            \n          //             {\n          //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n          //               dataForAction: {\n          //                 type: 'string:...',\n          //                 data: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token is here! pre-downloaded!\n          //               }\n          //             },\n                      \n          //             {\n          //               matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //               dataForAction: {\n          //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //                 data: {\n          //                   matchFunctionNode: {\n          //                     // query here!\n          //                     // action_pointer:0.0.1:local:238972ncr\n          //                     type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                     data: {\n          //                       code: `(()=>{\n          //                         // Action \n          //                         // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                  \n          //                         let inputNode = INPUT.data.inputNode;\n                                  \n          //                         if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.data.learn != 'generic_cloud_second'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.nodeId){\n          //                           // should be root-level!\n          //                           return null;\n          //                         }\n                                  \n          //                         // strip childnodes\n          //                         // delete inputNode.nodes; \n          //                         // delete inputNode.parent;\n          //                         delete inputNode.data;\n          \n          //                         return inputNode;\n                                  \n          //                       })()`\n          //                     }\n          //                   },\n          //                   // expected/allowed schemas for return \n          //                   // outputSchemas: [\n          //                   //   'query_result:0.0.1:local:32490usfj23o23f',\n          //                   //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //                   // ]\n          //                 }\n          //               }\n          //             }\n          //           ]\n                    \n          //         }\n          //       }\n          //     }\n          //   }\n          // });\n          \n          // // console.log('Got Response from TalkToSecond3'); //, JSON.stringify(response,null,2));\n          \n          // // Response should include code! \n          // let codeResultNode = universe.lodash.find(response.data.actionResponses[1].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          \n          \n          // console.log('Got Code to Run for generic_cloud_second');\n          \n          // // return resolve({\n          // //   runningRemoteCode: true,\n          // //   codeResultNode_type: codeResultNode.type\n          // // });\n          \n          // // Run code in local VM \n          // // - INPUT.data is ExternalIdentityNode \n          // // - clears local memory, gets remote app, KEEPS local identity! \n          // let localResult = await universe.runNodeCodeInVM({\n          //   codeNode: codeResultNode,\n          //   dataNode: INPUT.data\n          // });\n          \n          // return resolve({\n          //   externalResponse: true,\n          //   response,\n          //   codeResultNode,\n          //   localResult\n          // })\n          \n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          \n          // console.log('incoming_web_request!!');\n          // return resolve({\n          //   ok: true\n          // });\n              \n          // if(INPUT.type == 'run_action:0.0.1:local:2398y294c23'){\n            // this is the main/expected input\n            let nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null // root-level\n                  // type: INPUT.type,\n                },\n                // function for returning data from the Node, after filtering a bit \n                // - includes both the Node, and Nodes with nodeId (pointers) \n                filterNodes: tmpNodes=>{\n                  // this runs isolated, outside of the above context? (not sure) \n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.filter(tmpNode=>{\n                      // see if has a ChildNode matching a type \n                      let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                        return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                      })\n                      // 'run_action:0.0.1:local:2398y294c23'\n                      if(!foundMatcherChild){\n                        return false;\n                      }\n                      \n                      // should have no Parent!\n                      // - todo: put into a specific \"directory\" or nodelist\n                      if(tmpNode.parent){\n                        return false;\n                      }\n                      \n                      return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                    });\n                    resolve(tmpNodes);\n                  });\n                },\n              }\n            });\n            \n            // return resolve({\n            //   nodes: nodes.length\n            // });\n            \n            \n            if(nodes.length === 1){\n              // found Node to run for action! \n    \n              let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n              \n              // run in vm, and pass in the inputSchema Node! \n              // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n              let actionResult;\n              try {\n                actionResult = await universe.runNodeCodeInVM({\n                  codeNode, // includes type/schemaName and data \n                  dataNode: INPUT.data, // should be another Node that can be used by the action! \n                  timeout: 15 * 1000\n                });\n              }catch(err){\n                return resolve('FAILED code from incoming_web_request');\n              }\n              \n              // validate actionResult!\n              // - todo\n              \n              return resolve(actionResult);\n              // { \n              //   txt: 'Response:', \n              //   nodeTypes: nodes.map(n=>n.type),\n              //   actionResult\n              // }); // + result);\n              \n            } else {\n              // no Node found for handling action :( \n                \n              return resolve({ \n                error: 'No Nodes for action (incoming_web_request)',\n                INPUT\n              }); // + result);\n            }\n            \n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          break;\n          \n          \n        default:\n          return resolve({\n            type: 'err:..',\n            data: {\n              msg: 'Missing valid input type',\n              INPUT\n            }\n          });\n      }\n\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129467537,"updatedAt":1513150417536,"parent":{"_id":"5a3085fb7e9fab3b612008fd","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_from_universe:0.0.1:local:298fj293","data":null,"active":true,"createdAt":1513129467223,"updatedAt":null},"nodes":[]}]},{"_id":"5a3085fb7e9fab3b612008ff","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Storing 'generic_cloud_second' here"},"active":true,"createdAt":1513129467846,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[]},{"_id":"5a3085fc7e9fab3b61200900","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129468145,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3085fc7e9fab3b61200901","nodeId":"5a3085fc7e9fab3b61200900","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action_sequence: This is for handling a sequence of actions!"},"active":true,"createdAt":1513129468477,"updatedAt":null,"parent":{"_id":"5a3085fc7e9fab3b61200900","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129468145,"updatedAt":null},"nodes":[]},{"_id":"5a3085fc7e9fab3b61200902","nodeId":"5a3085fc7e9fab3b61200900","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action_sequence:0.0.1:local:293fh8239hsdf23f"},"active":true,"createdAt":1513129468801,"updatedAt":null,"parent":{"_id":"5a3085fc7e9fab3b61200900","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129468145,"updatedAt":null},"nodes":[]},{"_id":"5a3085fd7e9fab3b61200903","nodeId":"5a3085fc7e9fab3b61200900","type":"code:0.0.1:local:32498h32f2","data":{"key":"2f6997c5-7c0f-4864-95e2-00b92047a427","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // return resolve({\n      //   multiple: 'todo: run multiple actions in sequence!'\n      // });\n      \n      // Should be piping information?? \n      // - just looping for now, expecting to store info in the cache, I guess?? \n      let actionResponses = [];\n      let continueActions = true;\n      for(let INPUT_data_idx in INPUT.data.actions){\n        if(!continueActions){\n          continue;\n        }\n        let INPUT_data = INPUT.data.actions[INPUT_data_idx];\n        \n        let x = 1; // this IS available in the filterNode function below!? \n        \n        let nodes = await universe.searchMemory({\n          filter: {\n            // sqlFilter: {\n            //   type: INPUT.type,\n            // },\n            // function for returning data from the Node, after filtering a bit \n            // - includes both the Node, and Nodes with nodeId (pointers) \n            filterNodes: tmpNodes=>{\n              // this runs isolated, outside of the above context? (not sure) \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  // see if has a ChildNode matching a type \n                  \n                  // // must match action type \n                  // if(tmpNode.type != INPUT.data.matchActionType){\n                  //   return false;\n                  // }\n                  // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  if(tmpNode.type != INPUT_data.matchActionType){\n                    return false;\n                  }\n                  // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                  \n                  // // must have code to run! \n                  // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                  //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                  // });\n                  \n                  // if(!foundChildCode){\n                  //   return false;\n                  // }\n                  \n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        \n        // return resolve({\n        //   test: 'ok',\n        //   typeMatch: INPUT.data.matchActionType,\n        //   nodes,\n        //   INPUT,\n        //   SELF\n        // });\n        \n        if(nodes && nodes.length){\n          // found Node to run for action! \n          // - assuming only 1 piece of Code possible/available \n          \n          let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n          \n          // run in vm, and pass in the inputSchema Node! \n          // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n          let actionResult;\n          try {\n            actionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode: INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              timeout: 25 * 1000\n            });\n          }catch(err){\n            // return resolve('FAILED action');\n            actionResponses.push({\n              error: true,\n              msg: 'Failed action',\n              err: (err || '').toString()\n            });\n            continueActions = false;\n            continue;\n          }\n          \n          // validate actionResult!\n          // - todo\n          \n          // adding actionResult to results output\n          // return resolve(actionResult);\n          actionResponses.push(actionResult);\n          \n        } else {\n          // no Node found for handling action :( \n            \n          // return resolve({ \n          //   error: 'No Nodes for action2'\n          // }); // + result);\n          actionResponses.push({ \n            action3: INPUT_data,\n            error: 'No Nodes for action2'\n          });\n        }\n        \n      }\n      \n      // resolve all\n      resolve({\n        actionResponses\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1513129469594,"updatedAt":1513150422322,"parent":{"_id":"5a3085fc7e9fab3b61200900","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129468145,"updatedAt":null},"nodes":[]}]},{"_id":"5a3085fd7e9fab3b61200904","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129469876,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3085fe7e9fab3b61200905","nodeId":"5a3085fd7e9fab3b61200904","type":"text_tag:0.0.1:local:239fj23","data":{"text":"generic_cloud_second_startup"},"active":true,"createdAt":1513129470211,"updatedAt":null,"parent":{"_id":"5a3085fd7e9fab3b61200904","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129469876,"updatedAt":null},"nodes":[]},{"_id":"5a3085fe7e9fab3b61200906","nodeId":"5a3085fd7e9fab3b61200904","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"cloud_startup:0.0.1:local:98h198hf32"},"active":true,"createdAt":1513129470546,"updatedAt":null,"parent":{"_id":"5a3085fd7e9fab3b61200904","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129469876,"updatedAt":null},"nodes":[]},{"_id":"5a3085fe7e9fab3b61200907","nodeId":"5a3085fd7e9fab3b61200904","type":"code:0.0.1:local:32498h32f2","data":{"key":"e32dd823-be68-4360-917a-48c0c8314bc5","code":"(()=>{\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // Handles \"startup\" on a cloud server \n      console.log('Startup on Cloud OK!');\n      \n      return resolve({\n        type: 'boolean:...',\n        data: true\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1513129470911,"updatedAt":1513150424787,"parent":{"_id":"5a3085fd7e9fab3b61200904","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129469876,"updatedAt":null},"nodes":[]}]},{"_id":"5a3085ff7e9fab3b61200908","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129471258,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3085ff7e9fab3b61200909","nodeId":"5a3085ff7e9fab3b61200908","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ping:pong"},"active":true,"createdAt":1513129471568,"updatedAt":null,"parent":{"_id":"5a3085ff7e9fab3b61200908","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129471258,"updatedAt":null},"nodes":[]},{"_id":"5a3085ff7e9fab3b6120090a","nodeId":"5a3085ff7e9fab3b61200908","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"ping:0.0.1:local:239fh298fh239h23"},"active":true,"createdAt":1513129471870,"updatedAt":null,"parent":{"_id":"5a3085ff7e9fab3b61200908","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129471258,"updatedAt":null},"nodes":[]},{"_id":"5a3086007e9fab3b6120090b","nodeId":"5a3085ff7e9fab3b61200908","type":"code:0.0.1:local:32498h32f2","data":{"key":"525d1100-71ab-40fc-893e-02940e7b7211","code":"(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      resolve({\n        type: 'pong:0.0.1:local:8992389hfdg',\n        data: 'pong'\n      })\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1513129472311,"updatedAt":1513150427768,"parent":{"_id":"5a3085ff7e9fab3b61200908","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129471258,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086007e9fab3b6120090c","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1513129472677,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086017e9fab3b6120090d","nodeId":"5a3086007e9fab3b6120090c","type":"code:0.0.1:local:32498h32f2","data":{"key":"619427af-8b4b-4c58-975f-9cc95f55d6f6","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'new':\n          console.log('Getting new rsa instance');\n          return resolve({\n            type: 's....',\n            data: new universe.rsa(inputOpts)\n          })\n          \n        \n        case 'sign':\n        \n          let stringToSign = inputOpts.stringToSign;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getPrivate',\n              options: {}\n            }\n          });\n          \n          console.log('MY privateIdentity NODE', MyPrivateIdentity);\n          \n          // // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          // let myPublicKey = MyPrivateIdentity.data.public;\n          \n          // let IdentityNode = await getPrivateIdentity();\n          let privateKey = MyPrivateIdentity.data.private;\n\n          let key1 = new universe.rsa(privateKey);\n          let signed = key1.sign(stringToSign);\n\n          return resolve({\n            type: 'string:0.0.1:local:289hf329h93',\n            data: signed.toString('base64')\n          });\n\n          \n        \n        case 'verify':\n          console.log('Verifying', inputOpts);\n          let ChallengeVerifyNode = inputOpts.ChallengeVerifyNode;\n          let key2 = new universe.rsa(ChallengeVerifyNode.data.publicKey);\n\n          let verified = key2.verify(ChallengeVerifyNode.data.challenge, ChallengeVerifyNode.data.solution, undefined, 'base64'); // todo\n\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: verified\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129473085,"updatedAt":1513150430739,"parent":{"_id":"5a3086007e9fab3b6120090c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1513129472677,"updatedAt":null},"nodes":[]},{"_id":"5a3086017e9fab3b6120090e","nodeId":"5a3086007e9fab3b6120090c","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: rsa"},"active":true,"createdAt":1513129473380,"updatedAt":null,"parent":{"_id":"5a3086007e9fab3b6120090c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1513129472677,"updatedAt":null},"nodes":[]},{"_id":"5a3086017e9fab3b6120090f","nodeId":"5a3086007e9fab3b6120090c","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129473704,"updatedAt":null,"parent":{"_id":"5a3086007e9fab3b6120090c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"rsa"},"active":true,"createdAt":1513129472677,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086027e9fab3b61200910","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1513129474008,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086027e9fab3b61200911","nodeId":"5a3086027e9fab3b61200910","type":"code:0.0.1:local:32498h32f2","data":{"key":"e7af1532-eb2b-45f6-8673-79199855e487","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let nodeResponse = await universe.loadAndRunCapability('Request',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'make',\n              options: {\n                ExternalIdentityNode,\n                RequestNode\n              }\n            }\n          });\n          \n          return resolve(nodeResponse);\n            \n          // let nodeResponse = await universe. TalkToSecond({\n          //   ExternalIdentityNode: INPUT,\n          //   InputNode: {\n          //     type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //     data: {\n          //       actions: [\n          //         {\n          //           matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //           dataForAction: {\n          //             type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //             data: {\n          //               matchFunctionNode: {\n          //                 // query here!\n          //                 // action_pointer:0.0.1:local:238972ncr\n          //                 type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                 data: {\n          //                   code: codeSearchTemplate\n          //                 }\n          //               },\n          //               // expected/allowed schemas for return \n          //               // outputSchemas: [\n          //               //   'query_result:0.0.1:local:32490usfj23o23f',\n          //               //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //               // ]\n          //             }\n          //           }\n          //         }\n          //       ]\n                \n          //     }\n          //   }\n          // });\n          \n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129474380,"updatedAt":1513150437549,"parent":{"_id":"5a3086027e9fab3b61200910","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1513129474008,"updatedAt":null},"nodes":[]},{"_id":"5a3086027e9fab3b61200912","nodeId":"5a3086027e9fab3b61200910","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: TalkToSecond"},"active":true,"createdAt":1513129474703,"updatedAt":null,"parent":{"_id":"5a3086027e9fab3b61200910","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1513129474008,"updatedAt":null},"nodes":[]},{"_id":"5a3086037e9fab3b61200913","nodeId":"5a3086027e9fab3b61200910","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129475063,"updatedAt":null,"parent":{"_id":"5a3086027e9fab3b61200910","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"TalkToSecond"},"active":true,"createdAt":1513129474008,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086037e9fab3b61200914","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1513129475512,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086037e9fab3b61200915","nodeId":"5a3086037e9fab3b61200914","type":"code:0.0.1:local:32498h32f2","data":{"key":"8900db23-3166-4efc-a099-e39cc790bc84","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, authToken } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      // return resolve({\n      //   INPUT\n      // });\n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      \n      // Need to create a local Identity, and authenticate with the remote Second to Learn from \n      // - uses a constant value (token) from the remote Second! \n      let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'getPrivate',\n          options: {}\n        }\n      });\n      \n      console.log('MY privateIdentity NODE', MyPrivateIdentity);\n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      // ExternalIdentityNode\n      console.log('Making ExternalInitialResponseNodeFull request');\n      let ExternalInitialResponseNodeFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedInitiateIdentifyNode\n          }\n        }\n      });\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      console.log('ExternalInitialResponseNodeFull',ExternalInitialResponseNodeFull);\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      console.log('Verifying challenge I sent', ExternalInitialResponseNode, ExternalIdentityNode);\n      let verified = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'verify',\n          options: {\n            ChallengeVerifyNode:{\n              type: '...',\n              data: {\n                challenge: newChallenge,\n                solution: ExternalInitialResponseNode.data.solution,\n                publicKey: ExternalIdentityNode.data.publicKey\n              }\n            }\n          }\n        }\n      });\n      \n      console.log('Local Verified response:', verified);\n      \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      \n      console.log('Signing remote challenge', ExternalInitialResponseNode);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign: ExternalInitialResponseNode.data.challenge\n          }\n        }\n      });\n      \n      console.log('Local SignedNode response:', SignedNode);\n      \n      \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      let privateConnectMethod = universe.lodash.find(MyPrivateIdentity.nodes, { type: 'private_identity_connect_method:0.0.1:local:9081j29h3' });\n      \n      console.log('AFter Search');\n      \n      if(privateConnectMethod){\n        console.log('Has privateConnectMethod!!!!', privateConnectMethod);\n      } else {\n        console.log('NO privateConnectMethod???');\n      }\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting an encrypted token back for later auth requests \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data, // base64 string \n          connectMethod: privateConnectMethod ? privateConnectMethod.data : undefined\n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      \n      console.log('Making ExternalTokenResponseFull request with WrappedTokenNode', WrappedTokenNode);\n      let ExternalTokenResponseFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedTokenNode\n          }\n        }\n      });\n      \n      console.log('Local ExternalTokenResponseFull response:', ExternalTokenResponseFull);\n      \n      \n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      console.log('AT IDENTIFY STAGE 2', ExternalIdentityNode);\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      \n      console.log('Updating ExternalIdentityNode', ExternalIdentityNode);\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      console.log('Updated!');\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129475863,"updatedAt":1513150443973,"parent":{"_id":"5a3086037e9fab3b61200914","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1513129475512,"updatedAt":null},"nodes":[]},{"_id":"5a3086047e9fab3b61200916","nodeId":"5a3086037e9fab3b61200914","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: IdentifyInitiate"},"active":true,"createdAt":1513129476762,"updatedAt":null,"parent":{"_id":"5a3086037e9fab3b61200914","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1513129475512,"updatedAt":null},"nodes":[]},{"_id":"5a3086057e9fab3b61200917","nodeId":"5a3086037e9fab3b61200914","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129477092,"updatedAt":null,"parent":{"_id":"5a3086037e9fab3b61200914","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"IdentifyInitiate"},"active":true,"createdAt":1513129475512,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086057e9fab3b61200918","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1513129477423,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086057e9fab3b61200919","nodeId":"5a3086057e9fab3b61200918","type":"code:0.0.1:local:32498h32f2","data":{"key":"e830f0fd-5313-48a7-8518-c431c5b4c7bb","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'createLocal': // should only happen once! \n          console.log('Create a new Local Private Identity');\n              \n          var key = new universe.rsa({b: 512});\n          key.generateKeyPair(512, 65537); // 2048\n          \n          const keypair = {\n            private: key.exportKey('pkcs8-private-pem'), \n            public: key.exportKey('pkcs8-public-pem'),\n          }\n          \n          let NodeToSave = {\n            type: 'identity_private:0.0.1:local:3298f2j398233',\n            data: keypair\n          }\n          \n          // save Node to memory\n          let savedNode = await universe.newNode(NodeToSave);\n          \n          // save the connectMethod as well \n          let connectionUrl = 'http://localhost:9999';\n          if(universe.env.HEROKU_APP_NAME){\n            connectionUrl = `http://${universe.env.HEROKU_APP_NAME}.herokuapp.com/ai`; \n          }\n          if(universe.env.PUBLIC_HOST == 'ngrok.io'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          if(universe.env.PUBLIC_HOST == 'herokuapp.com'){\n            connectionUrl = `http://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n          }\n          console.log('CONNECTION_URL:', connectionUrl);\n          \n          let childNodeToSave = {\n            nodeId: savedNode._id,\n            type: 'private_identity_connect_method:0.0.1:local:9081j29h3',\n            data: {\n              method: 'http',\n              connection: connectionUrl\n            }\n          }\n          \n          let savedChildNode = await universe.newNode(childNodeToSave);\n          // delete savedChildNode.parent; // kill recursion\n          savedNode.nodes = [savedChildNode];\n          \n          return resolve(savedNode);\n          \n        case 'getPrivate':\n        \n          let privateNodes;\n          try{\n            privateNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'identity_private:0.0.1:local:3298f2j398233'\n                }\n              }\n            });\n            if(!privateNodes.length){\n              throw \"No private identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no identity'\n            });\n          }\n\n          let IdentityNode = privateNodes[0];\n          return resolve(IdentityNode);\n          \n        case 'getExternal':\n        \n          let externalNodes;\n          try{\n            externalNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: inputOpts.publicKey\n                  }\n                }\n              }\n            });\n            if(!externalNodes.length){\n              throw \"No external identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no external identity match'\n            });\n          }\n\n          let ExternalIdentityNode = externalNodes[0];\n          return resolve(ExternalIdentityNode);\n          \n          \n        case 'registerOnChain':\n          let remoteCreated = await universe.createAddressForIdentity(inputOpts.words, inputOpts.publicKey, inputOpts.connection)\n          return resolve(remoteCreated);\n          \n          \n        case 'saveExternal':\n          // Duplicate publicKeys get updated! \n          \n          console.log('saveExternal inputOpts', inputOpts);\n          \n          let externalNodes3 = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n                }\n              }\n            }\n          });\n          \n          let NodeToSave3 = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n            }\n          }\n          \n          if(externalNodes3 && externalNodes3.length){\n            // exists!\n            NodeToSave3._id = externalNodes3[0]._id;\n          }\n          \n          // external_identity:0.0.1:local:8982f982j92\n          // external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // save Node to memory\n          let savedNode3;\n          if(NodeToSave3._id){\n            savedNode3 = await universe.updateNode(NodeToSave3);\n          } else {\n            savedNode3 = await universe.newNode(NodeToSave3);\n          }\n          \n          // save/update the connectMethod as well \n          if(inputOpts.ExternalIdentityNode.nodes){\n            let childNodeToSave3 = {\n              nodeId: savedNode3._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: inputOpts.ExternalIdentityNode.nodes[0].data\n            }\n            \n            let savedChildNode3;\n            if(externalNodes3 && externalNodes3.length && externalNodes3[0].nodes){\n              childNodeToSave3._id = externalNodes3[0].nodes[0]._id;\n              savedChildNode3 = await universe.updateNode(childNodeToSave3);\n            } else {\n              savedChildNode3 = await universe.newNode(childNodeToSave3);\n            }\n          }\n          \n          console.log('Saved External, locally');\n          \n          let NewExternalNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getExternal',\n              options: {\n                publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n              }\n            }\n          });\n          \n          console.log('Got New/UpdatedExternalNode', NewExternalNode);\n          \n          return resolve(NewExternalNode);\n          \n          \n        \n        case 'getAddressForWords':\n          // inputOpts.words = String;\n          // transform to \"string[space]string[space]string[space]\" format \n          let remoteValue = universe.lodash.compact(inputOpts.words.split(' ')).join(' ');\n          // transform to wallet address \n          var hash = universe.bitcoin.crypto.sha256(remoteValue)\n          console.log('hash:', hash);\n          var d = universe.bigi.fromBuffer(hash)\n          console.log('d:', d);\n          var keyPair = new universe.bitcoin.ECPair(d)\n          var address = keyPair.getAddress()\n          console.log('Remote Second Wallet Address', address);\n          return resolve({\n            type:'wallet_address:..',\n            data: address\n          })\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129477723,"updatedAt":1513150448835,"parent":{"_id":"5a3086057e9fab3b61200918","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1513129477423,"updatedAt":null},"nodes":[]},{"_id":"5a3086067e9fab3b6120091a","nodeId":"5a3086057e9fab3b61200918","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Identity"},"active":true,"createdAt":1513129478025,"updatedAt":null,"parent":{"_id":"5a3086057e9fab3b61200918","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1513129477423,"updatedAt":null},"nodes":[]},{"_id":"5a3086067e9fab3b6120091b","nodeId":"5a3086057e9fab3b61200918","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129478355,"updatedAt":null,"parent":{"_id":"5a3086057e9fab3b61200918","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Identity"},"active":true,"createdAt":1513129477423,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086067e9fab3b6120091c","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1513129478724,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086077e9fab3b6120091d","nodeId":"5a3086067e9fab3b6120091c","type":"code:0.0.1:local:32498h32f2","data":{"key":"90bd3427-5301-415d-ac12-c3f9a3c530d0","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'make':\n        \n          console.log('Make Request inputOpts', inputOpts);\n          \n          // Make a request to an external Second \n          // inputOpts: {\n          //   ExternalIdentityNode, // must include connect_method\n          //   RequestNode: InitiateIdentifyNode\n          // }\n          \n          // let ExternalRequestNode = inputOpts.ExternalIdentityNode;\n\n          // ExternalIdentityNode needs to have a NodeChild w/ a connect_method \n          let connectNode = universe.lodash.find(inputOpts.ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n          if(!connectNode){\n            console.error('Missing ConnectNode!');\n            return reject({\n              type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n              data: {\n                str: 'Missing existing ExternalIdentity connect_method child!'\n              }\n            })\n          }\n\n          console.log('Making external request');\n\n          // make web request\n          // - just passing through, assume any Auth is already included? \n          let response = await universe.directToSecond({\n            url: connectNode.data.connection,\n            RequestNode: inputOpts.RequestNode,\n            // method: 'post',\n            // url: connectNode.data.connection, // expecting URL at first! \n            // body: ExternalRequestNode.data.RequestNode,\n            // json: true\n          })\n\n          // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          return resolve(response.secondResponse);\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129479555,"updatedAt":1513150454454,"parent":{"_id":"5a3086067e9fab3b6120091c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1513129478724,"updatedAt":null},"nodes":[]},{"_id":"5a3086077e9fab3b6120091e","nodeId":"5a3086067e9fab3b6120091c","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: Request"},"active":true,"createdAt":1513129479922,"updatedAt":null,"parent":{"_id":"5a3086067e9fab3b6120091c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1513129478724,"updatedAt":null},"nodes":[]},{"_id":"5a3086087e9fab3b6120091f","nodeId":"5a3086067e9fab3b6120091c","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129480244,"updatedAt":null,"parent":{"_id":"5a3086067e9fab3b6120091c","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"Request"},"active":true,"createdAt":1513129478724,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086097e9fab3b61200920","type":"internal_user:0.0.1:local:98h32","data":{"passphrase":"testuserpassphrase","roles":["root"]},"active":true,"createdAt":1513129481004,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[]},{"_id":"5a3086097e9fab3b61200921","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30860a7e9fab3b61200922","nodeId":"5a3086097e9fab3b61200921","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129482777,"updatedAt":null,"parent":{"_id":"5a3086097e9fab3b61200921","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null},"nodes":[]},{"_id":"5a30860c7e9fab3b61200923","nodeId":"5a3086097e9fab3b61200921","type":"code:0.0.1:local:32498h32f2","data":{"key":"85ad165c-ff0a-43ce-9973-557aaa933357","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Receiving an INPUT.data.passphrase for logging in! \n      // - MUST already be identified (in requests hash) \n      // - upgrades the internal hash to include a user?\n      \n      // get whatever is currently stored \n      // internalUserPassphrase = passphrase\n\n      // Find the InternalUser with that passphrase \n      // - todo: bcrypt! \n      \n      // if found User, then create a new Token that will be used for Identity \n      \n      // INPUT = {\n      //   type: 'internal_user_passphrase:0.0.1:local:289fh239h38h2',\n      //   data: {\n      //     passphrase: String\n      //   }\n      // }\n      \n      let requestCache = await universe.getRequestCache();\n      \n      let IdentityNode;\n      try {\n        IdentityNode = requestCache.keyvalue.IdentityNode;\n      }catch(err){\n      }\n      \n      if(!IdentityNode){\n        return resolve({\n          type: 'error:...',\n          data: {\n            msg: 'Missing IdentityNode in request (should use a run_action_sequence and include auth!)'\n          }\n        });\n      }\n      \n      \n      \n      \n      // Find the InternalUser for that passphrase \n      let internalUserMatches = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null,\n            type: 'internal_user:0.0.1:local:98h32',\n            data: {\n              passphrase: INPUT.data.passphrase\n            }\n          }\n        }\n      });\n      \n      if(!internalUserMatches || !internalUserMatches.length){\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Missing InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase,\n            INPUT\n          }\n        });\n      }\n      \n      if(internalUserMatches.length > 1){\n        console.error('Matched multiple internalUsers!');\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Multiple InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase\n          }\n        });\n      }\n      \n      let InternalUserNode = internalUserMatches[0];\n      \n      \n      // Upgrade the user's token with the InternalUser Node \n      \n      \n      \n      // Return a new token to use for subsequent requests \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: IdentityNode._id, //ExternalIdentityNode._id,\n          publicKey: IdentityNode.data.publicKey,\n          internalUserId: InternalUserNode._id\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds',\n        data: {\n          verified: true,\n          token,\n          IdentityNode\n        }\n      });\n        \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129484364,"updatedAt":1513150457600,"parent":{"_id":"5a3086097e9fab3b61200921","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null},"nodes":[]},{"_id":"5a30860e7e9fab3b61200924","nodeId":"5a3086097e9fab3b61200921","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: Upgrade token for identified external (incoming) as an Internal User. Given a passphrase"},"active":true,"createdAt":1513129486261,"updatedAt":null,"parent":{"_id":"5a3086097e9fab3b61200921","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null},"nodes":[]},{"_id":"5a30860f7e9fab3b61200925","nodeId":"5a3086097e9fab3b61200921","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129487693,"updatedAt":null,"parent":{"_id":"5a3086097e9fab3b61200921","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null},"nodes":[]},{"_id":"5a3086117e9fab3b61200926","nodeId":"5a3086097e9fab3b61200921","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129489638,"updatedAt":null,"parent":{"_id":"5a3086097e9fab3b61200921","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_token_upgrade_to_internal_user:0.0.1:local:9281198u","data":null,"active":true,"createdAt":1513129481371,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086127e9fab3b61200927","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086187e9fab3b61200928","nodeId":"5a3086127e9fab3b61200927","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129496011,"updatedAt":null,"parent":{"_id":"5a3086127e9fab3b61200927","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null},"nodes":[]},{"_id":"5a30861b7e9fab3b61200929","nodeId":"5a3086127e9fab3b61200927","type":"code:0.0.1:local:32498h32f2","data":{"key":"cab7f1c9-d371-4b3c-8e34-1289a9821bb1","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // // INPUT:\n      // {\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: 'randomstring/nonce'\n      // }\n      \n      // Challenge start\n      // - get sent something to prove who I am (or who I represent [am signing for])\n      //   - this might be different than what the requestor is expecting! they should handle it accordingly \n      // - return my public key, signed challenge \n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      \n      \n      \n      let newChallenge = universe.uuidv4();\n      \n      \n      // universe.console.log('GOT2 NewChallenge:', INPUT.data.challenge, newChallenge); //, INPUT.data.challenge);\n      \n      \n      // Just using capabilities to sign \n      // - signed result is a StringNode \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: INPUT.data.challenge\n      });\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      //- todo...\n      \n      // Store our challenge (and the publicKey we were sent) in memory, to check in another request/response!\n      universe.globalCache[INPUT.data.publicKey] = newChallenge;\n      \n      \n      resolve({\n        type: 'challenge_start_response:0.0.1:local:2378f37723f22dxc',\n        data: {\n          solution: SignedNode.data,\n          challenge: newChallenge\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129499208,"updatedAt":1513150461417,"parent":{"_id":"5a3086127e9fab3b61200927","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null},"nodes":[]},{"_id":"5a30861e7e9fab3b6120092a","nodeId":"5a3086127e9fab3b61200927","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: start challenge"},"active":true,"createdAt":1513129502843,"updatedAt":null,"parent":{"_id":"5a3086127e9fab3b61200927","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null},"nodes":[]},{"_id":"5a3086217e9fab3b6120092b","nodeId":"5a3086127e9fab3b61200927","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129505923,"updatedAt":null,"parent":{"_id":"5a3086127e9fab3b61200927","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null},"nodes":[]},{"_id":"5a3086247e9fab3b6120092c","nodeId":"5a3086127e9fab3b61200927","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129508555,"updatedAt":null,"parent":{"_id":"5a3086127e9fab3b61200927","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_start:0.0.1:local:3892fh83h46","data":null,"active":true,"createdAt":1513129490989,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086267e9fab3b6120092d","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30862a7e9fab3b6120092e","nodeId":"5a3086267e9fab3b6120092d","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129514641,"updatedAt":null,"parent":{"_id":"5a3086267e9fab3b6120092d","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null},"nodes":[]},{"_id":"5a30862e7e9fab3b6120092f","nodeId":"5a3086267e9fab3b6120092d","type":"code:0.0.1:local:32498h32f2","data":{"key":"08b17f71-3221-4919-a875-af0b4522f81b","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Challenge solved by caller (or so they say) \n      // - create Node for ExternalIdentity: publicKey, approvedDatetime\n      // - return JWT that client should use for subsequent requests \n      \n      // old: also receiving an INPUT.data.internalUserPassphrase for logging in! \n      \n      let storedChallenge = universe.globalCache[INPUT.data.publicKey];\n      \n      // check stored challenge with passed-in (any reason? seems ok) \n      if(storedChallenge != INPUT.data.challengeReceived){\n        return resolve({\n          type: 'error',\n          data: {\n            str: 'invalid storedChallenge != challengeReceived'\n          }\n        })  \n      }\n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: storedChallenge,\n          solution: INPUT.data.solution,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      if(!verified.data){\n        return resolve({\n          type: 'error...',\n          data: {\n            err: 'Failed verifiation!'\n          }\n        });\n      }\n      \n      // Create local Node for ExternalIdentity \n      // - they should have already passed up a token I can use for auth (if I want to reach this Second again) \n      // - should also have the connect_method setup! \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data.publicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      let ExternalIdentityNode\n      if(nodes.length){\n        // Exists already \n        ExternalIdentityNode = nodes[0];\n        \n        // todo: get updated connectMethod!!!\n        universe.console.error('Expecting connectMethod for one we are creating');\n        universe.console.error('Received:', JSON.stringify(INPUT, null, 2));\n        \n        // update connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          if(ExternalIdentityNode.nodes){\n            // has existing connect_method to be updated\n            \n            console.log('Updating existing connect_method for external child');\n            \n            let updateChild = {\n              _id: ExternalIdentityNode.nodes[0]._id,\n              nodeId: ExternalIdentityNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let updatedChild = await universe.updateNode(updateChild);\n            \n          } else {\n            // no existing connect_method\n            let newChild = {\n              nodeId: savedNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let savedChild = await universe.newNode(newChild);\n          }\n        }\n        \n        \n      } else {\n        // no Node created yet (this is expected for each \"new\" Second) \n        \n        // go ahead and create new ExternalIdentityNode \n        // - also creating the Connect Method to use \n        //   - it would have been sent up (\"reach me X way\") \n        \n        let newNode = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            publicKey: INPUT.data.publicKey\n          }\n        }\n        \n        let savedNode = await universe.newNode(newNode);\n        \n        // create connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          let newChild2 = {\n            nodeId: savedNode._id,\n            type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n            data: INPUT.data.connectMethod\n          }\n          let savedChild2 = await universe.newNode(newChild2);\n        }\n        \n        // get normal Node for rest of call \n        ExternalIdentityNode = await universe.findNode({_id: savedNode._id});\n        \n      }\n      \n      \n      // // get internal_user that we are authorizing as (using \"upgrade\" path now...)\n      // // - should ERROR if fail! \n      // if(INPUT.data.internalUserPassphrase){\n        \n      // }\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      // Created encrypted token for identification \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: ExternalIdentityNode._id,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'challenge_token_response:0.0.1:local:928h92h3223fdfsdf23',\n        data: {\n          verified: true,\n          token\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129518486,"updatedAt":1513150465056,"parent":{"_id":"5a3086267e9fab3b6120092d","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null},"nodes":[]},{"_id":"5a3086327e9fab3b61200930","nodeId":"5a3086267e9fab3b6120092d","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: challenge response (solved, proving who I am). Saving External locally. Returning JWT."},"active":true,"createdAt":1513129522163,"updatedAt":null,"parent":{"_id":"5a3086267e9fab3b6120092d","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null},"nodes":[]},{"_id":"5a3086377e9fab3b61200931","nodeId":"5a3086267e9fab3b6120092d","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129527066,"updatedAt":null,"parent":{"_id":"5a3086267e9fab3b6120092d","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null},"nodes":[]},{"_id":"5a30863f7e9fab3b61200932","nodeId":"5a3086267e9fab3b6120092d","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129535561,"updatedAt":null,"parent":{"_id":"5a3086267e9fab3b6120092d","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_response:0.0.1:local:3289h988h293fh8h","data":null,"active":true,"createdAt":1513129510985,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086427e9fab3b61200933","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086467e9fab3b61200934","nodeId":"5a3086427e9fab3b61200933","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129542569,"updatedAt":null,"parent":{"_id":"5a3086427e9fab3b61200933","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null},"nodes":[]},{"_id":"5a30864a7e9fab3b61200935","nodeId":"5a3086427e9fab3b61200933","type":"code:0.0.1:local:32498h32f2","data":{"key":"87889324-ce31-45f8-b80d-4f6d7a39f356","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let nodeId;\n      let publicKey;\n      let internalUserId; // for InternalUser \n      let InternalUserNode;\n      let tokenNode;\n      let decrypted;\n      let encrypted;\n      try {\n        \n          \n        // // Created encrypted token for identification \n        // let tokenDataString = JSON.stringify({\n        //   type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        //   data: {\n        //     internalId: null,\n        //     publicKey: 'learn'\n        //   }\n        // });\n        // // encrypt_string:0.0.1:local:329fj2938\n        // encrypted = await universe.capabilities().encryptPrivate({\n        //   type: 'string',\n        //   data: tokenDataString\n        // });\n        \n        decrypted = await universe.capabilities().decryptPrivate({\n          type: 'string',\n          data: INPUT.data\n        });\n        \n        // get the local public key from decrypted package (JSON string) \n        if(decrypted.type != 'string:0.0.1:local:289hf329h93'){\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: false,\n            extra: {\n              msg: 'Failed decrypting INPUT.data',\n              inputData: INPUT.data ? INPUT.data : 'NO INPUT DATA PROVIDED',\n              INPUT,\n              decrypted,\n              // encrypted,\n            }\n          });\n        }\n        tokenNode = JSON.parse(decrypted.data);\n        \n        nodeId = tokenNode.data.internalId;\n        publicKey = tokenNode.data.publicKey;\n        internalUserId = tokenNode.data.internalUserId;\n        // todo: expiresAt (force re-auth)\n      }catch(err){\n        return resolve({\n          type: 'boolean:0.0.1:local:98h8fh28h3232f',\n          data: false,\n          extra: {\n            INPUT,\n            decrypted,\n            // encrypted,\n            verified: false,\n            err: true,\n            errStr: err.toString()\n          }\n        });\n      }\n      \n      // create some default ExternalIdentityNodes for certain private keys \n      // - \"learning\" for example\n      let ExternalIdentityNode;\n      \n      switch(publicKey){\n        case 'learn':\n          // allow anyone who was pre-allowed \n            \n          ExternalIdentityNode = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              roles: ['learn'],\n              publicKey\n            }\n          }\n          \n          break;\n        \n        \n        default:\n          // actual publicKey passed in \n          \n          // Get local ExternalIdentity if it exists \n          // - should exist, unless we deleted it! \n          let nodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                _id: nodeId,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: publicKey\n                }\n              },\n              // function for returning data from the Node, after filtering a bit \n              // - includes both the Node, and Nodes with nodeId (pointers) \n              filterNodes: tmpNodes=>{\n                return tmpNodes;\n              }\n            }\n          });\n          \n          if(!nodes || !nodes.length){\n            \n            return resolve({\n              type: 'boolean:0.0.1:local:98h8fh28h3232f',\n              data: {\n                missingNode: true,\n                INPUT,\n              }\n            });\n            \n          }\n          \n          ExternalIdentityNode = nodes[0];\n          \n          // see if the InternalUser should also be included\n          if(internalUserId){\n            let InternalUserNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  _id: internalUserId,\n                  type: 'internal_user:0.0.1:local:98h32',\n                }\n              }\n            });\n            if(InternalUserNodes.length){\n              InternalUserNode = InternalUserNodes[0];\n            } else {\n              console.error('Missing as InternalUser');\n            }\n          }\n           \n          break;\n        \n      }\n      \n      \n      // set in request cache \n      await universe.setRequestCacheKeyValue('IdentityNode',ExternalIdentityNode);\n      await universe.setRequestCacheKeyValue('InternalUserNode',InternalUserNode);\n      \n      return resolve({\n        type: 'boolean:0.0.1:local:98h8fh28h3232f',\n        data: true,\n        ExternalIdentityNode,\n        decrypted,\n        internalUserId,\n        InternalUserNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129546968,"updatedAt":1513150469513,"parent":{"_id":"5a3086427e9fab3b61200933","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null},"nodes":[]},{"_id":"5a30864e7e9fab3b61200936","nodeId":"5a3086427e9fab3b61200933","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: adds ExternalIdentity to requestsCache, according to the token that is passed in"},"active":true,"createdAt":1513129550790,"updatedAt":null,"parent":{"_id":"5a3086427e9fab3b61200933","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null},"nodes":[]},{"_id":"5a3086537e9fab3b61200937","nodeId":"5a3086427e9fab3b61200933","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129555019,"updatedAt":null,"parent":{"_id":"5a3086427e9fab3b61200933","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null},"nodes":[]},{"_id":"5a30865f7e9fab3b61200938","nodeId":"5a3086427e9fab3b61200933","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129567794,"updatedAt":null,"parent":{"_id":"5a3086427e9fab3b61200933","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_via_token:0.0.1:local:237823783g2123","data":null,"active":true,"createdAt":1513129538841,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086657e9fab3b61200939","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086697e9fab3b6120093a","nodeId":"5a3086657e9fab3b61200939","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129577352,"updatedAt":null,"parent":{"_id":"5a3086657e9fab3b61200939","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null},"nodes":[]},{"_id":"5a30866e7e9fab3b6120093b","nodeId":"5a3086657e9fab3b61200939","type":"code:0.0.1:local:32498h32f2","data":{"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return resolve({\n      //   SEARCHING: 'seraching internal datasource!',\n      //   INPUT,\n      //   SELF\n      // });\n      \n      // schema/format of INPUT data: standard_query_request:0.0.1:local:65723f2khfds\n      \n      await universe.historyLog({INPUT}, 'searching-internal-datasource', 'debug')\n      \n      \n      // When searching: (permissions) \n      // - search is coming from a remote user (always!!!) \n      // - checking \"permission functions\" to determine what data to share \n      // - should already have created the AuthUser (in the universe.responsesCache) and other relevant permission information \n      \n      \n      // get all base (no nodeId) Nodes .... actually, get ALLLLLL Nodes! \n      // for each Node, run the permission functions \n      // - each child node (in the tree, go all the way down, recurse up!) \n      // after doing all child Nodes, do the parent Node \n      // - undefined means to leave it out \n      // - use universe.requestsCache for AuthUser, etc. \n      // after running all the permission functions, pass the Node to the parent \n      // return an array, without running any more analysis (do v2 locally) \n      \n      // permission functions are per-Node (stored as a type:permission_function that has a type:code as a NodeChild) \n      // permission functions are also per-Type, stored as a single Node for the type, of type:type_permission_function\n      \n      let startTime = (new Date()).getTime();\n      \n      let vmFuncCount = 0;\n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            // // type: NODE.type,\n            // nodeId: null,\n            active: true\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            \n            // action_pointer:0.0.1:local:238972ncr\n            \n            return new Promise((resolve, reject)=>{\n              // if(x==1){\n              //   resolve([{type:'FAKE'}]);\n              // }\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      \n      // loading all the PermissionNodes that are for method:read, cuz we'll repeatedly try each \n      let permissionFunctionNodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: \"permission_function:0.0.1:local:2387872h3f2\",\n            nodeId: null // top-level\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                return tmpNode.data.method == 'read';\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      permissionFunctionNodes = universe.lodash.sortBy(permissionFunctionNodes,funcNode=>{\n        let orderNode = universe.lodash.find(funcNode.nodes, {type: 'order_level:0.0.1:local:382hf273'});\n        return orderNode ? orderNode.data.level:0;\n      });\n      \n      let memoryTime = (new Date()).getTime();\n      \n      // await universe.historyLog({}, 'searching-internal-datasource2', 'debug')\n      \n      // return resolve({\n      //   nodes: nodes.length\n      // });\n      \n      let workGroup = (new Date()).getTime().toString(); // use this for concurrency\n      \n      let requestCache = await universe.getRequestCache({});\n      \n      // Instead of creating a bunch of small VMs to run...\n      // - assuming this container is OK \n      // - run analysis of the code snippets to make sure they are OK to run \n      // - use \"eval\" and create locally-accessible variables \n      // ....end result: exponentially faster \n      \n      \n      // Fetched all Nodes \n      // - iterate over nodes \n      let returnNodes = [];\n      let promises = [];\n      // for(let node of nodes){\n      nodes.forEach(node=>{\n        \n        promises.push(new Promise(async (resolve,reject)=>{\n          \n          // if node is undefined now, continue to the next one\n          if(!node){\n            // continue;\n            return resolve();\n          }\n          \n          \n          // returnNodes.push(node);\n          // return resolve();\n          \n          // Get all General PermissionFunctions \n          // - iterate through each \n          // - most will simply say \"i'm not concerned with this NodeType/Scenario\" \n          // - ordering by the \"type:order_level ChildNode\" \n          let returnedMoreThanPassThrough = false;\n          for(let funcNode of permissionFunctionNodes){\n            if(!node){\n              // skipping more permissionFunctions cuz already denied! \n              continue;\n            }\n            \n            // each permissionFunction can return 1 of 3 things: \n            // - true: if had no effect/match, passed-through \n            // - object: aka \"specifically allowed\" - passed permission function, potentially modified object on pass-through  \n            // - undefined: not allowed \n            \n            let codeNode = universe.lodash.find(funcNode.nodes, {type: 'code:0.0.1:local:32498h32f2'});\n            let simpleCompareNode = universe.lodash.find(funcNode.nodes, {type: 'simple_compare:0.0.1:local:298fy38y283'});\n            \n            let strFunc;\n            let permissionResult;\n            try {\n              \n              // permissionResult = await universe.runNodeCodeInVM({\n              //   codeNode, // includes type/schemaName and data.code\n              //   dataNode: node, // should be another Node that can be used by the action! \n              //   // timeout: 5000\n              //   workGroup,\n              //   workers: 10\n              // });\n              \n              \n              vmFuncCount++;\n              // permissionResult = await universe.runNodeCodeInVMSimple({\n              //   codeNode: simpleCompareNode, // includes type/schemaName and data.code\n              //   dataNode: {\n              //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              //     data: {\n              //       inputNode: node, // should be another Node that can be used by the action! \n              //       requestCache \n              //     }\n              //   }\n              // });\n              \n              strFunc = simpleCompareNode.data.code;\n              let INPUT = {\n                type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n                data: {\n                  inputNode: node,\n                  requestCache\n                }\n              }\n              let miniverse = {\n                lodash: universe.lodash\n              }\n              // console.log('strFunc:',strFunc.length);\n              permissionResult = eval(strFunc); // can't use Function cuz loses local scope\n              permissionResult = await Promise.resolve(permissionResult)\n              \n            }catch(err){\n              // return resolve('FAILED code from incoming_web_request');\n              permissionResult = undefined;\n              console.error('Failed in code from permission_function',err, strFunc);\n            }\n            \n            // await universe.historyLog({typeofp: (typeof permissionResult), permissionResult}, 'permission_result', 'debug')\n        \n            switch(typeof permissionResult){\n              case 'boolean':\n                if(!permissionResult){\n                  node = undefined;\n                }\n                break;\n                \n              case 'object':\n                returnedMoreThanPassThrough = true;\n                node = permissionResult;\n                break;\n                \n              default:\n                // result was undefined,null,etc.\n                node = undefined;\n                break;\n            }\n            \n          }\n          \n          // ...finished permissionFunctions \n          \n          if(!node){\n            // process next node \n            // continue;\n            return resolve();\n          }\n          \n          // if all the results are \"true\" (aka only did pass-through) then DENY! \n          // - defaulting to \"don't show shit\" :) \n          if(!returnedMoreThanPassThrough){\n            // continue;\n            return resolve();\n          }\n          \n          \n          returnNodes.push(node);\n          return resolve();\n          \n          // permission functions should also be adding to the \"permissionQueue\" \n          // - make it easier to say \"if I passed X permission, then ignore this thing\" \n          // - kinda already there by default: could modify the request keyValue store and stack? \n          //   - but not able to do that from miniverse...race condition for \"next\" permissionFunction? \n          \n          // permission_function:0.0.1:local:2387872h3f2\n          \n          \n          // Get permissionFunctions for this NodeType \n          // - fetch first single Node that has type:permission_function_for_type (or use \"has common_name:permission_function\"??) \n          \n          // Get final \"global\" permissionFunction \n          // - per-user? \n          // - what other permission functions should run? \n          \n          \n        }));\n        \n        \n      });\n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource3 (got return nodes)', 'debug')\n      \n      Promise.all(promises)\n      .then(async ()=>{\n        \n        console.log('vmFuncCountSetup:', vmFuncCount);\n      \n        // after we determine what a user is allowed to see...\n        // - manipulate === see !! (dont pretend that keeping things hidden here prevents what a user can output) \n        // - could easily say \"match Nodes that have X\" and even though we hide X, they know it exists cuz the ParentNode comes back \n        \n        // pass resulting Node to user's provided MatchFunction to see if this is a Node they want returned \n        // - their function also handles the amount of data they want to receive (any Children, etc.) \n        // - returning undefined means they DO NOT want it included \n        \n        let middleTime = (new Date()).getTime();\n        \n        let finalReturnNodes = [];\n        for(let node of returnNodes){\n          \n          let transformedResult;\n          let strFunc = INPUT.data.matchFunctionNode.data.code;\n          \n          try {\n            // vmFuncCount++;\n            // transformedResult = await universe.runNodeCodeInVMSimple({\n            //   codeNode: INPUT.data.matchFunctionNode, // includes type/schemaName and data.code\n            //   dataNode: {\n            //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n            //     data: {\n            //       inputNode: node, // should be another Node that can be used by the action! \n            //       // requestCache \n            //     }\n            //   }\n            //   // timeout: 5000\n            // });\n            \n            let INPUT = {\n              type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              data: {\n                inputNode: node,\n                // requestCache\n              }\n            }\n            let miniverse = {\n              lodash: universe.lodash\n            }\n            // console.log('strFunc:',strFunc.length);\n            transformedResult = eval(strFunc); // can't use Function cuz loses local scope\n            transformedResult = await Promise.resolve(transformedResult)\n          }catch(err){\n            // return resolve('FAILED code from incoming_web_request');\n            transformedResult = undefined;\n            console.error('Failed user function:', err);\n          }\n          \n          if(transformedResult){\n            finalReturnNodes.push(transformedResult);\n          }\n          \n        }\n        \n        \n        let endTime = (new Date()).getTime();\n        \n//         universe.console.log(`\n// Internal Search Times: \n// total: ${(endTime - startTime)/1000}\n// searchMemorySetup: ${(memoryTime - startTime)/1000}\n// internalSetup: (${nodes.length}) ${(middleTime - memoryTime)/1000}\n// userFuncs: (${returnNodes.length}) ${(endTime - middleTime)/1000}\n// vmFuncCount: ${vmFuncCount}\n//         `);\n            \n        resolve({\n          type: 'list_of_nodes:0.0.1:local:3289f2',\n          data: finalReturnNodes\n        });\n        \n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","key":"7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"},"active":true,"createdAt":1513129582764,"updatedAt":1513195869968,"parent":{"_id":"5a3086657e9fab3b61200939","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null},"nodes":[]},{"_id":"5a3086757e9fab3b6120093c","nodeId":"5a3086657e9fab3b61200939","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: search internal datasource (people searching my data) Nodes"},"active":true,"createdAt":1513129589873,"updatedAt":null,"parent":{"_id":"5a3086657e9fab3b61200939","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null},"nodes":[]},{"_id":"5a30867e7e9fab3b6120093d","nodeId":"5a3086657e9fab3b61200939","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129598292,"updatedAt":null,"parent":{"_id":"5a3086657e9fab3b61200939","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null},"nodes":[]},{"_id":"5a3086837e9fab3b6120093e","nodeId":"5a3086657e9fab3b61200939","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129603797,"updatedAt":null,"parent":{"_id":"5a3086657e9fab3b61200939","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_internal_datasource:0.0.1:local:2h3ufih8s9h2f","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    \n    // NODE is...?\n    await universe.historyLog({NODE}, 'in-code-log', 'debug')\n    \n    // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n    let nodes = await universe.searchMemory({\n      filter: {\n        // sqlFilter: {\n        //   type: NODE.type,\n        // },\n        // function for returning data from the Node, after filtering a bit \n        // - includes both the Node, and Nodes with nodeId (pointers) \n        filterNodes: tmpNodes=>{\n          // this runs isolated, outside of the above context? (not sure) \n          \n          // action_pointer:0.0.1:local:238972ncr\n          \n          return new Promise((resolve, reject)=>{\n            // if(x==1){\n            //   resolve([{type:'FAKE'}]);\n            // }\n            resolve(tmpNodes);\n          });\n        },\n      }\n    });\n    \n    resolve(nodes);\n    \n    \n    \n  })\n})()"},"active":true,"createdAt":1513129573871,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086867e9fab3b6120093f","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1513129606488,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30868a7e9fab3b61200940","nodeId":"5a3086867e9fab3b6120093f","type":"order_level:0.0.1:local:382hf273","data":{"level":1000},"active":true,"createdAt":1513129610222,"updatedAt":null,"parent":{"_id":"5a3086867e9fab3b6120093f","nodeId":"5a3085fa7e9fab3b612008fc","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1513129606488,"updatedAt":null},"nodes":[]},{"_id":"5a30868d7e9fab3b61200941","nodeId":"5a3086867e9fab3b6120093f","type":"simple_compare:0.0.1:local:298fy38y283","data":{"code":"(()=>{\n  \n  // has childNode of correct type! \n  return INPUT.data.inputNode;\n  \n})()"},"active":true,"createdAt":1513129613470,"updatedAt":null,"parent":{"_id":"5a3086867e9fab3b6120093f","nodeId":"5a3085fa7e9fab3b612008fc","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1513129606488,"updatedAt":null},"nodes":[{"_id":"5a3086927e9fab3b61200942","nodeId":"5a30868d7e9fab3b61200941","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ALLOWING EVERYTHING!"},"active":true,"createdAt":1513129618959,"updatedAt":null,"parent":{"_id":"5a30868d7e9fab3b61200941","nodeId":"5a3086867e9fab3b6120093f","type":"simple_compare:0.0.1:local:298fy38y283","data":{"code":"(()=>{\n  \n  // has childNode of correct type! \n  return INPUT.data.inputNode;\n  \n})()"},"active":true,"createdAt":1513129613470,"updatedAt":null},"nodes":[]}]},{"_id":"5a30869c7e9fab3b61200943","nodeId":"5a3086867e9fab3b6120093f","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129628732,"updatedAt":null,"parent":{"_id":"5a3086867e9fab3b6120093f","nodeId":"5a3085fa7e9fab3b612008fc","type":"permission_function:0.0.1:local:2387872h3f2","data":{"method":"read"},"active":true,"createdAt":1513129606488,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086a37e9fab3b61200944","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129635450,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086a77e9fab3b61200945","nodeId":"5a3086a37e9fab3b61200944","type":"incoming_query_type_matcher:0.0.1:local:3242rx23rd3","data":{"typeMatch":"run_action:0.0.1:local:2398y294c23"},"active":true,"createdAt":1513129639280,"updatedAt":null,"parent":{"_id":"5a3086a37e9fab3b61200944","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129635450,"updatedAt":null},"nodes":[]},{"_id":"5a3086ac7e9fab3b61200946","nodeId":"5a3086a37e9fab3b61200944","type":"code:0.0.1:local:32498h32f2","data":{"key":"a821e596-0a28-4b2f-98f7-0211c636e475","code":"(()=>{\n  \n  // This code handles an incoming \"run_action...\"\n  // - finds possible actions, passes action data in! \n  \n  // can use SELF node to check for CodeSchema of Pointer (or adject/sibling CodeSchema if I have a ParentNode/nodeId?)! \n  // - to find my own Child nodes! \n  \n  // find \"INPUT.data.matchActionType\" \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      let x = 1; // this IS available in the filterNode function below!? \n      \n      let nodes = await universe.searchMemory({\n        filter: {\n          // sqlFilter: {\n          //   type: INPUT.type,\n          // },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                // see if has a ChildNode matching a type \n                \n                // // must match action type \n                // if(tmpNode.type != INPUT.data.matchActionType){\n                //   return false;\n                // }\n                // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                //   return false;\n                // }\n                \n                // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                //   return false;\n                // }\n                \n                if(tmpNode.type != INPUT.data.matchActionType){\n                  return false;\n                }\n                // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                \n                // // must have code to run! \n                // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                // });\n                \n                // if(!foundChildCode){\n                //   return false;\n                // }\n                \n                return true;\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      // return resolve({\n      //   test: 'ok',\n      //   typeMatch: INPUT.data.matchActionType,\n      //   nodes,\n      //   INPUT,\n      //   SELF\n      // });\n      \n      if(nodes && nodes.length){\n        // found Node to run for action! \n        // - assuming only 1 piece of Code possible/available \n        \n        let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n        \n        // run in vm, and pass in the inputSchema Node! \n        // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n        let actionResult;\n        try {\n          actionResult = await universe.runNodeCodeInVM({\n            codeNode, // includes type/schemaName and data \n            dataNode: INPUT.data.dataForAction, // should be another Node that can be used by the action! \n            timeout: 5000\n          });\n        }catch(err){\n          return resolve('FAILED action');\n        }\n        \n        // validate actionResult!\n        // - todo\n        \n        return resolve(actionResult);\n        // { \n        //   txt: 'Response:', \n        //   nodeTypes: nodes.map(n=>n.type),\n        //   actionResult\n        // }); // + result);\n        \n      } else {\n        // no Node found for handling action :( \n          \n        return resolve({ \n          error: 'No Nodes for action in run_action (1):',\n          action: INPUT.data.matchActionType\n        }); // + result);\n      }\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"},"active":true,"createdAt":1513129644264,"updatedAt":1513150475741,"parent":{"_id":"5a3086a37e9fab3b61200944","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129635450,"updatedAt":null},"nodes":[]},{"_id":"5a3086b07e9fab3b61200947","nodeId":"5a3086a37e9fab3b61200944","type":"text_tag:0.0.1:local:239fj23","data":{"text":"run_action call handler!"},"active":true,"createdAt":1513129648154,"updatedAt":null,"parent":{"_id":"5a3086a37e9fab3b61200944","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129635450,"updatedAt":null},"nodes":[]},{"_id":"5a3086b57e9fab3b61200948","nodeId":"5a3086a37e9fab3b61200944","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129653293,"updatedAt":null,"parent":{"_id":"5a3086a37e9fab3b61200944","nodeId":"5a3085fa7e9fab3b612008fc","type":"incoming_query_function:0.0.1:local:2389f3923","data":null,"active":true,"createdAt":1513129635450,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086b87e9fab3b61200949","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086bb7e9fab3b6120094a","nodeId":"5a3086b87e9fab3b61200949","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129659861,"updatedAt":null,"parent":{"_id":"5a3086b87e9fab3b61200949","nodeId":"5a3085fa7e9fab3b612008fc","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null},"nodes":[]},{"_id":"5a3086bf7e9fab3b6120094b","nodeId":"5a3086b87e9fab3b61200949","type":"code:0.0.1:local:32498h32f2","data":{"key":"267e87c1-8497-4eeb-8af6-4e50e0098a6f","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // todo: make a request to a remote Second to be taught something \n      // - \"i want to learn about X\" \n      \n      let saved;\n      try {\n        saved = await universe.updateNode(INPUT.data);\n        saved = {\n          type: 'saved_node:...',\n          data: saved\n        }\n      }catch(err){\n        saved = {\n          type: 'error_failed_saving:...',\n          data: {\n            error: true,\n            err: err.toString()\n          }\n        }\n      }\n      \n      resolve({\n        saved,\n        INPUT\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129663736,"updatedAt":1513150480639,"parent":{"_id":"5a3086b87e9fab3b61200949","nodeId":"5a3085fa7e9fab3b612008fc","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null},"nodes":[]},{"_id":"5a3086c37e9fab3b6120094c","nodeId":"5a3086b87e9fab3b61200949","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: update a Node by passing in the new Node"},"active":true,"createdAt":1513129667005,"updatedAt":null,"parent":{"_id":"5a3086b87e9fab3b61200949","nodeId":"5a3085fa7e9fab3b612008fc","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null},"nodes":[]},{"_id":"5a3086c67e9fab3b6120094d","nodeId":"5a3086b87e9fab3b61200949","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129670224,"updatedAt":null,"parent":{"_id":"5a3086b87e9fab3b61200949","nodeId":"5a3085fa7e9fab3b612008fc","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null},"nodes":[]},{"_id":"5a3086ca7e9fab3b6120094e","nodeId":"5a3086b87e9fab3b61200949","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129674077,"updatedAt":null,"parent":{"_id":"5a3086b87e9fab3b61200949","nodeId":"5a3085fa7e9fab3b612008fc","type":"update_node:0.0.1:local:392821982y3","data":null,"active":true,"createdAt":1513129656670,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086ce7e9fab3b6120094f","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129678292,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086d37e9fab3b61200950","nodeId":"5a3086ce7e9fab3b6120094f","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129683203,"updatedAt":null,"parent":{"_id":"5a3086ce7e9fab3b6120094f","nodeId":"5a3085fa7e9fab3b612008fc","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129678292,"updatedAt":null},"nodes":[]},{"_id":"5a3086d87e9fab3b61200951","nodeId":"5a3086ce7e9fab3b6120094f","type":"code:0.0.1:local:32498h32f2","data":{"key":"c9825374-18ab-414e-bad3-011830343c74","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      let { optionsNode, dataNode } = INPUT.data;\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: dataNode.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: dataNode.type,\n        nodeId: dataNode.nodeId,\n        data: dataNode.data\n      }\n      \n      if(nodes.length && !optionsNode.data.skipExistingLearnedNodeId){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      // - this should be an option, passed as a Node (instead of having INPUT as the Node!) \n      let savedNodeChild;\n      if(dataNode._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: dataNode._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        type: 'node:...',\n        data: savedNode,\n          // child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129688634,"updatedAt":1513150484665,"parent":{"_id":"5a3086ce7e9fab3b6120094f","nodeId":"5a3085fa7e9fab3b612008fc","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129678292,"updatedAt":null},"nodes":[]},{"_id":"5a3086dc7e9fab3b61200952","nodeId":"5a3086ce7e9fab3b6120094f","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: forcing to learn a single new Node (handles nodeId and whatnot too!)"},"active":true,"createdAt":1513129692109,"updatedAt":null,"parent":{"_id":"5a3086ce7e9fab3b6120094f","nodeId":"5a3085fa7e9fab3b612008fc","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129678292,"updatedAt":null},"nodes":[]},{"_id":"5a3086e17e9fab3b61200953","nodeId":"5a3086ce7e9fab3b6120094f","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129697281,"updatedAt":null,"parent":{"_id":"5a3086ce7e9fab3b6120094f","nodeId":"5a3085fa7e9fab3b612008fc","type":"forced_learn_node:0.0.1:local:34907234987sf23","data":{"codeIGNORE":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: NODE.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: NODE.type,\n        data: NODE.data\n      }\n      \n      if(nodes.length){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      let savedNodeChild;\n      if(NODE._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: NODE._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        node: savedNode,\n        child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"},"active":true,"createdAt":1513129678292,"updatedAt":null},"nodes":[]}]},{"_id":"5a3086ea7e9fab3b61200954","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a3086f77e9fab3b61200955","nodeId":"5a3086ea7e9fab3b61200954","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129719377,"updatedAt":null,"parent":{"_id":"5a3086ea7e9fab3b61200954","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null},"nodes":[]},{"_id":"5a3086ff7e9fab3b61200956","nodeId":"5a3086ea7e9fab3b61200954","type":"code:0.0.1:local:32498h32f2","data":{"key":"04589537-9255-4026-92bd-8e3e9b7358d6","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Being passed in the publicKey we want to initiate a challenge with \n      // - also sending our \"connect_method\" info (if it exists) \n      \n      \n      // INPUT.type == \"challenge_init_remote:0.0.1:...\"\n      // INPUT.data == { \n      //   ExternalIdentityNode: { data: {publicKey:Strig}, nodes: [connect_method] }\n      // }\n      \n      // Save ExternalIdentityNode locally! \n      // - required before Identifying \n      // - saveExternal *should* handle duplicates (and updating the initial AuthPassphrase) \n      let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'saveExternal',\n          options: {\n            ExternalIdentityNode: INPUT.data.ExternalIdentityNode // should contain a connection method! \n          }\n        }\n      });\n      \n      console.log('Saved new/updated ExternalIdentityNode', ExternalIdentityNode);\n      \n      \n      // Authenticate with External Second \n      // - make authenticated requests to a Second (necessary for Learning?) \n      //   - should have ALL requests authenticated \n      // universe.setupExternalSecond();\n      let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'start',\n          options: {\n            externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n            // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          }\n        }\n      });\n      \n      return resolve({\n        ExternalIdentityNode,\n        authExternalIdentityNode\n      })\n      \n      // // return resolve({\n      // //   msg: 'Being asked to auth with a remote!',\n      // //   INPUT\n      // // });\n      \n      \n      \n      // // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // // INPUT: \n      // // {\n      // //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      // //   data: 'string'\n      // // }\n      \n      \n      // // Initiates a challenge with an external Second \n      // // - ExternalIdentity should ALREADY EXIST locally! \n      // //   - look it up from nodes by INPUT.data.publicKey \n      // // - lookup by data:publicKey, childNode:type:connect_method \n      // // - checks for local ExternalIdentity first! \n      // // - \n      \n      // // return resolve({\n      // //   INPUT\n      // // });\n      \n      \n      // // Get local ExternalIdentity if it exists \n      // let nodes = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       type: 'external_identity:0.0.1:local:8982f982j92',\n      //       data: {\n      //         publicKey: INPUT.data\n      //       }\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       return tmpNodes;\n      //     }\n      //   }\n      // });\n      \n      // if(!nodes.length){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity node',\n      //       publicKey: INPUT.data\n      //     }\n      //   })\n      // }\n      \n      // let ExternalIdentityNode = nodes[0];\n      // // else {\n      // //   ExternalIdentityNode = {\n      // //     // no _id yet! (will create/update later!) \n      // //     type: 'external_identity:0.0.1:local:8982f982j92',\n      // //     data: {\n      // //       publicKey:INPUT.data\n      // //     }\n      // //   }\n      // // }\n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // // Initiate Auth Steps \n      // // - send my publicKey, new challengeText that we want validated \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      // universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // // make Node request to datasource\n      // let InitiateIdentifyNode = {\n      //   type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challenge: newChallenge\n      //   }\n      // }\n      // let WrappedInitiateIdentifyNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n      //     dataForAction: InitiateIdentifyNode\n      //   }\n      // }\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      // // response includes the \"output_generic\" wrapper \n      // let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // // successful response: challenge_start_response\n      // // return resolve({\n      // //   ok: 'test1',\n      // //   response: ExternalInitialResponse\n      // // });\n      \n      // // Received:\n      // // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // // - \n      \n      \n      // // Verify challenge I sent \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // // boolean Node is returned\n      // if(!verified.data){\n      //   return resolve({\n      //     err: 'Failed verifiation!',\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   });\n      // }\n      \n      \n      // // return resolve({\n      // //   verified: verified\n      // // });\n      \n      \n      // // Verified external! \n      // // - now need to identify myself, by answering the challenge I was sent \n      // // - really this could be completed in reverse (but might as well just do it here!) \n      // //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      \n      // // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // // - getting a JWT back! \n      // let GetIdentityTokenNode = {\n      //   type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challengeReceived: ExternalInitialResponseNode.data.challenge,\n      //     solution: SignedNode.data // base64 string \n      //   }\n      // }\n      // let WrappedTokenNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n      //     dataForAction: GetIdentityTokenNode\n      //   }\n      // }\n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // // return resolve({\n      // //   x: 1,\n      // //   ExternalTokenResponseFull\n      // // });\n      \n      // // response includes the \"output_generic\" wrapper \n      // let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // // save updated ExternalIdentityNode\n      // ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      // let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // // todo: save\n      \n      // // check for publicKey info (ok to allow this person?) \n      // // - after I send them something to sign and actually get their identity...\n      \n      // resolve({\n      //   type: 'challenge_finish:0.0.1:local:2983jf982',\n      //   data: {\n      //     SUCCESS: {\n      //       ExternalInitialResponseNode,\n      //       ExternalTokenResponseNode,\n      //       SignedNode_data: SignedNode.data,\n      //       updatedExternalIdentityNode\n      //     }\n      //   }\n      // });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129727079,"updatedAt":1513150488889,"parent":{"_id":"5a3086ea7e9fab3b61200954","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null},"nodes":[]},{"_id":"5a3087067e9fab3b61200957","nodeId":"5a3086ea7e9fab3b61200954","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: initiate an external connection (act as Client)"},"active":true,"createdAt":1513129734926,"updatedAt":null,"parent":{"_id":"5a3086ea7e9fab3b61200954","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null},"nodes":[]},{"_id":"5a30870d7e9fab3b61200958","nodeId":"5a3086ea7e9fab3b61200954","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129741597,"updatedAt":null,"parent":{"_id":"5a3086ea7e9fab3b61200954","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null},"nodes":[]},{"_id":"5a3087117e9fab3b61200959","nodeId":"5a3086ea7e9fab3b61200954","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129745531,"updatedAt":null,"parent":{"_id":"5a3086ea7e9fab3b61200954","nodeId":"5a3085fa7e9fab3b612008fc","type":"identify_challenge_initiate:0.0.1:local:8239hf28hf283h","data":null,"active":true,"createdAt":1513129706864,"updatedAt":null},"nodes":[]}]},{"_id":"5a3087167e9fab3b6120095a","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1513129750748,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30871b7e9fab3b6120095b","nodeId":"5a3087167e9fab3b6120095a","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: take a request and search a remote datasource. Does NOT reduce the query at all (that would be handled in a more complex Action type:search_datasources_and_reduce)"},"active":true,"createdAt":1513129755456,"updatedAt":null,"parent":{"_id":"5a3087167e9fab3b6120095a","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1513129750748,"updatedAt":null},"nodes":[]},{"_id":"5a30871e7e9fab3b6120095c","nodeId":"5a3087167e9fab3b6120095a","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129758867,"updatedAt":null,"parent":{"_id":"5a3087167e9fab3b6120095a","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1513129750748,"updatedAt":null},"nodes":[]},{"_id":"5a3087247e9fab3b6120095d","nodeId":"5a3087167e9fab3b6120095a","type":"code:0.0.1:local:32498h32f2","data":{"key":"142170be-9d26-4858-8ed6-dffa875fef96","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Get my token for the remote datasource \n      \n      let nodeId = INPUT.data.internalId;\n      let publicKey = INPUT.data.publicKey;\n      \n      // Get local ExternalIdentity if it exists \n      // - should exist, unless we deleted it! \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            _id: nodeId,\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            // data: {\n            //   publicKey: publicKey\n            // }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes || !nodes.length){\n        \n        return resolve({\n          type: 'error:..',\n          data: {\n            msg: 'No ExternalIdentityNode when finding'\n          }\n        });\n        \n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      let token = ExternalIdentityNode.data.token;\n      \n      // ExternalIdentityNode.data.test1 = 'test1';\n      // let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      \n      // return resolve({\n      //   ExternalIdentityNode,\n      //   token\n      // })\n      // let token = await universe.capabilities().\n      // run_action_sequence:0.0.1:local:293fh8239hsdf23f\n      \n                \n      let data = {\n        type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n        data: {\n          actions: [\n            \n            {\n              matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              dataForAction: {\n                type: 'string:...',\n                data: token\n              }\n            }\n                    \n            // {\n            //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n            //   dataForAction: {\n            //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n            //     data: {\n            //       matchFunctionNode: {\n            //         // query here!\n            //         // action_pointer:0.0.1:local:238972ncr\n            //         type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n            //         data: {\n            //           code: `(()=>{\n            //             // Action \n            //             // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n    \n            //             let inputNode = INPUT.data.inputNode;\n    \n            //             let actionSearch = {\n            //               type: 'action_pointer:0.0.1:local:238972ncr', // should use \"common_type\" ?? \n            //             }\n            //             let hasActionPointerChild = miniverse.lodash.find(inputNode.nodes, actionSearch);\n    \n            //             if(!hasActionPointerChild){\n            //               return false;\n            //             }\n    \n            //             // strip childnodes\n            //             delete inputNode.nodes;\n            //             // delete inputNode.parent;\n            //             delete inputNode.data;\n    \n            //             return inputNode;\n            //           })()`\n            //         }\n            //       },\n            //       // expected/allowed schemas for return \n            //       outputSchemas: [\n            //         'query_result:0.0.1:local:32490usfj23o23f',\n            //         'internal_error_output:0.0.1:local:32948x2u3cno2c'\n            //       ]\n            //     }\n            //   }\n            // }\n          \n          ]\n        }\n      }\n      let response;\n      try {\n        response = await universe.webrequest.post({\n          url: 'http://localhost:7005/ai',\n          // url: 'http://google.com',\n          body: data,\n          json: true\n        });\n      }catch(err){\n        return resolve({\n          error: true,\n          err,\n          errStr: err.toString()\n        });\n      }\n      \n      resolve({\n        remoteResponse: response\n      });\n    }catch(err){\n      reject(err);\n    }\n  })\n})()"},"active":true,"createdAt":1513129764585,"updatedAt":1513150492685,"parent":{"_id":"5a3087167e9fab3b6120095a","nodeId":"5a3085fa7e9fab3b612008fc","type":"search_remote_datasource:0.0.1:local:3249sfj2389fh289","data":null,"active":true,"createdAt":1513129750748,"updatedAt":null},"nodes":[]}]},{"_id":"5a3087297e9fab3b6120095e","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30872f7e9fab3b6120095f","nodeId":"5a3087297e9fab3b6120095e","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129775182,"updatedAt":null,"parent":{"_id":"5a3087297e9fab3b6120095e","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null},"nodes":[]},{"_id":"5a3087367e9fab3b61200960","nodeId":"5a3087297e9fab3b6120095e","type":"code:0.0.1:local:32498h32f2","data":{"key":"63c8bfa5-289b-4d8b-b8f5-6e8908fd1ac2","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n      //   data: {\n      //     fileName: String,\n      //     fileType: String\n      //   }\n      // }\n      \n      \n      try {\n        \n        universe.console.log('Getting SignedUrlNode1');\n        \n        let SignedUrlNode = await universe.loadAndRunCapability('File',{},{\n          type: 'standard_capability_action:0.0.1:local:298j291bs',\n          data: {\n            action: 'signUpload',\n            options: {\n              type: '...',\n              data: INPUT.data\n            }\n          }\n        });\n        \n        \n        universe.console.log('Getting SignedUrlNode2');\n        \n        return resolve({\n          type: 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd',\n          data: SignedUrlNode.data\n        });\n        \n      }catch(err){\n        console.error('FAILED File.signUpload',err);\n        \n        return resolve({\n          // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed File.signUpload',\n            INPUT,\n            error: true,\n            err: err\n          }\n        });\n        \n      }\n      \n      // try {\n          \n      //   const s3 = new universe.aws.S3();\n      //   const fileName = INPUT.data.fileName;\n      //   const fileType = INPUT.data.fileType;\n      //   const s3Params = {\n      //     Bucket: universe.env.S3_BUCKET,\n      //     Key: fileName,\n      //     Expires: 60,\n      //     ContentType: fileType,\n      //     // ACL: 'public-read'\n      //     ACL: 'private'\n      //   };\n      \n      //   s3.getSignedUrl('putObject', s3Params, (err, data) => {\n      //     if(err){\n      //       universe.console.log('aws error:', err);\n                \n      //       return resolve({\n      //         // savedNode\n      //         type: 'error2:..',\n      //         data: {\n      //           INPUT,\n      //           error: true,\n      //           err: err.toString()\n      //         }\n      //       });\n      //       // return res.end();\n      //     }\n      //     const returnData = {\n      //       signedRequest: data,\n      //       url: `https://${universe.env.S3_BUCKET}.s3.amazonaws.com/${fileName}`\n      //     };\n      //     // res.write(JSON.stringify(returnData));\n      //     // res.end();\n            \n      //     return resolve({\n      //       type: 'request_file_upload_response:0.0.1:local:89h91h9f2nsmfd',\n      //       data: returnData\n      //     });\n          \n      //   });\n        \n        \n      // }catch(err){\n      //   return resolve({\n      //     // savedNode\n      //     type: 'error:..',\n      //     data: {\n      //       INPUT,\n      //       error: true,\n      //       err: err.toString()\n      //     }\n      //   });\n      // }\n      \n      \n      \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129782870,"updatedAt":1513150498838,"parent":{"_id":"5a3087297e9fab3b6120095e","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null},"nodes":[]},{"_id":"5a30873a7e9fab3b61200961","nodeId":"5a3087297e9fab3b6120095e","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: return a token for uploading a file to S3"},"active":true,"createdAt":1513129786906,"updatedAt":null,"parent":{"_id":"5a3087297e9fab3b6120095e","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null},"nodes":[]},{"_id":"5a3087487e9fab3b61200962","nodeId":"5a3087297e9fab3b6120095e","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129800483,"updatedAt":null,"parent":{"_id":"5a3087297e9fab3b6120095e","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null},"nodes":[]},{"_id":"5a30874f7e9fab3b61200963","nodeId":"5a3087297e9fab3b6120095e","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129807434,"updatedAt":null,"parent":{"_id":"5a3087297e9fab3b6120095e","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_upload:0.0.1:local:00838923flkwne","data":null,"active":true,"createdAt":1513129769052,"updatedAt":null},"nodes":[]}]},{"_id":"5a3087567e9fab3b61200964","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30875c7e9fab3b61200965","nodeId":"5a3087567e9fab3b61200964","type":"action_pointer:0.0.1:local:238972ncr","data":null,"active":true,"createdAt":1513129820099,"updatedAt":null,"parent":{"_id":"5a3087567e9fab3b61200964","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null},"nodes":[]},{"_id":"5a3087627e9fab3b61200966","nodeId":"5a3087567e9fab3b61200964","type":"code:0.0.1:local:32498h32f2","data":{"key":"096ef003-9e52-4f4c-8d84-3a38d71088a7","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n      //   data: {\n      //     key: String,\n      //   }\n      // }\n      \n      try {\n        let SignedUrlNode = await universe.loadAndRunCapability('File',{},{\n          type: 'standard_capability_action:0.0.1:local:298j291bs',\n          data: {\n            action: 'signGet',\n            options: {\n              type: '...',\n              data: {\n                key: INPUT.data.key\n              }\n            }\n          }\n        });\n        \n        return resolve({\n          type: 'request_file_get_response:0.0.1:local:902jf908j139001',\n          data: SignedUrlNode.data\n        });\n        \n      }catch(err){\n        console.error('FAILED File.signGet',err);\n        \n        return resolve({\n          // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed File.signGet',\n            INPUT,\n            error: true,\n            err: err.toString()\n          }\n        });\n        \n      }\n      \n      \n      \n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129826753,"updatedAt":1513150510274,"parent":{"_id":"5a3087567e9fab3b61200964","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null},"nodes":[]},{"_id":"5a3087677e9fab3b61200967","nodeId":"5a3087567e9fab3b61200964","type":"text_tag:0.0.1:local:239fj23","data":{"text":"ACTION: return a signed url to download a file from s3"},"active":true,"createdAt":1513129831052,"updatedAt":null,"parent":{"_id":"5a3087567e9fab3b61200964","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null},"nodes":[]},{"_id":"5a30876b7e9fab3b61200968","nodeId":"5a3087567e9fab3b61200964","type":"common_type:0.0.1:local:298fh29h2323f","data":"action","active":true,"createdAt":1513129835381,"updatedAt":null,"parent":{"_id":"5a3087567e9fab3b61200964","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null},"nodes":[]},{"_id":"5a30876f7e9fab3b61200969","nodeId":"5a3087567e9fab3b61200964","type":"include_in_copy:0.0.1:local:k2fj23443f4","data":{"slugs":["learn"]},"active":true,"createdAt":1513129839589,"updatedAt":null,"parent":{"_id":"5a3087567e9fab3b61200964","nodeId":"5a3085fa7e9fab3b612008fc","type":"request_file_get:0.0.1:local:239hfskhf0j9s","data":null,"active":true,"createdAt":1513129814573,"updatedAt":null},"nodes":[]}]},{"_id":"5a3087757e9fab3b6120096a","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"File"},"active":true,"createdAt":1513129845844,"updatedAt":null,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[{"_id":"5a30877a7e9fab3b6120096b","nodeId":"5a3087757e9fab3b6120096a","type":"code:0.0.1:local:32498h32f2","data":{"key":"18758d2d-4380-4475-b694-15290a223074","code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      const s3 = new universe.aws.S3();\n      \n      console.log('Loaded Capability: File');\n            \n      switch(inputAction){\n        case 'signUpload':\n          \n          // inputOpts: {\n          //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n          //   data: {\n          //     fileName: String,\n          //     fileType: String\n          //   }\n          // }\n            \n          try {\n              \n            // const fileName = inputOpts.data.fileName; // keep file extensions? \n            const fileName = universe.uuidv4(); // + '.png';\n            \n            const fileType = inputOpts.data.fileType;\n            const s3Params = {\n              Bucket: universe.env.S3_BUCKET,\n              Key: fileName,\n              Expires: 60,\n              ContentType: fileType,\n              // ACL: 'public-read'\n              ACL: 'private'\n            };\n          \n            s3.getSignedUrl('putObject', s3Params, (err, data) => {\n              \n              if(err){\n                universe.console.log('aws error:', err);\n                    \n                return resolve({\n                  // savedNode\n                  type: 'error2:..',\n                  data: {\n                    inputOpts,\n                    error: true,\n                    err: err\n                  }\n                });\n                // return res.end();\n              }\n              \n              const returnData = {\n                signedRequest: data,\n                url: `https://${universe.env.S3_BUCKET}.s3.amazonaws.com/${fileName}`,\n                key: fileName\n              };\n              // res.write(JSON.stringify(returnData));\n              // res.end();\n              \n              return resolve({\n                type: 'sign_upload_response:0.0.1:local:2891785cvw',\n                data: returnData\n              });\n              \n            });\n            \n          }catch(err){\n            console.error('SIGN ERROR!');\n            return resolve({\n              // savedNode\n              type: 'error:..',\n              data: {\n                msg: 'failed sign_upload',\n                INPUT,\n                error: true,\n                err: err\n              }\n            });\n          }\n          break;\n        \n        case 'signGet':\n        \n          // inputOpts: {\n          //   type: 'request_file_upload:0.0.1:local:00838923flkwne',\n          //   data: {\n          //     key: String,\n          //   }\n          // }\n            \n          try {\n            \n            universe.console.log('Capability: signGet');\n            \n            const myBucket = universe.env.S3_BUCKET;\n            const myKey = inputOpts.data.key;\n            const signedUrlExpireSeconds = 60 * 1; // 1 minutes\n            \n            const signedUrl = s3.getSignedUrl('getObject', {\n                Bucket: myBucket,\n                Key: myKey,\n                Expires: signedUrlExpireSeconds\n            })\n            \n            universe.console.log('Capability: signGet DONE');\n            \n            return resolve({\n              type: 'sign_get_response:0.0.1:local:8923782hf87sdjkh6',\n              data: {\n                url: signedUrl\n              }\n            });\n            \n            \n          }catch(err){\n            return resolve({\n              // savedNode\n              type: 'error:..',\n              data: {\n                msg: 'failed sign_get',\n                INPUT,\n                error: true,\n                err: err\n              }\n            });\n          }\n          break;\n        \n        default:\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"},"active":true,"createdAt":1513129850818,"updatedAt":1513150515867,"parent":{"_id":"5a3087757e9fab3b6120096a","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"File"},"active":true,"createdAt":1513129845844,"updatedAt":null},"nodes":[]},{"_id":"5a3087857e9fab3b6120096c","nodeId":"5a3087757e9fab3b6120096a","type":"text_tag:0.0.1:local:239fj23","data":{"text":"Capability: File"},"active":true,"createdAt":1513129861270,"updatedAt":null,"parent":{"_id":"5a3087757e9fab3b6120096a","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"File"},"active":true,"createdAt":1513129845844,"updatedAt":null},"nodes":[]},{"_id":"5a30878b7e9fab3b6120096d","nodeId":"5a3087757e9fab3b6120096a","type":"common_type:0.0.1:local:298fh29h2323f","data":"capability","active":true,"createdAt":1513129867925,"updatedAt":null,"parent":{"_id":"5a3087757e9fab3b6120096a","nodeId":"5a3085fa7e9fab3b612008fc","type":"capability:0.0.1:local:187h78h23","data":{"version":"1.0.0","key":"File"},"active":true,"createdAt":1513129845844,"updatedAt":null},"nodes":[]}]},{"_id":"5a30bc3253bec44114760500","type":"folder:0.0.1:local:2898293sfsdf3cv","data":{"key":"teaching_sources","name":"code nodes for teaching sources"},"active":true,"createdAt":1513143346610,"updatedAt":1513143422381,"parent":{"_id":"5a3085fa7e9fab3b612008fc","nodeId":null,"type":"parent_of_nodes_to_learn:0.0.1:local:2839fh29","data":{"learn":"teacher_second"},"active":true,"createdAt":1513129466414,"updatedAt":1513130130466},"nodes":[]}]